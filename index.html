<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DACUM Live Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/docx@7.8.2/build/index.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-align: center;
            font-weight: 700;
        }

        h2 {
            color: #2c3e50;
            font-size: 1.8em;
            margin-bottom: 20px;
            font-weight: 600;
        }

        h3 {
            color: #34495e;
            font-size: 1.4em;
            margin-bottom: 15px;
            font-weight: 600;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 14px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 1.05em;
            margin-bottom: 10px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        input[type="text"]:focus, textarea:focus {
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }

        button {
            cursor: pointer;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1.05em;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .btn-add {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .btn-add:hover {
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        .btn-remove {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .btn-remove:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4);
        }

        .btn-export {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            padding: 14px 28px;
            font-size: 1.15em;
        }

        .btn-export:hover {
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
        }

        .btn-export-word {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 14px 28px;
            font-size: 1.15em;
        }

        .btn-export-word:hover {
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4);
        }

        .btn-save-data {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 14px 28px;
            font-size: 1.15em;
        }

        .btn-save-data:hover {
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        .btn-load-data {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 14px 28px;
            font-size: 1.15em;
        }

        .btn-load-data:hover {
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.4);
        }

        .btn-clear-all {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 14px 28px;
            font-size: 1.15em;
        }

        .btn-clear-all:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4);
        }

        input[type="date"] {
            padding: 14px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1.05em;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: border-color 0.3s, box-shadow 0.3s;
            width: 100%;
        }

        input[type="date"]:focus {
            border-color: #667eea;
            outline: none;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }

        .info-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left: 6px solid #f59e0b;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        .info-box h3 {
            color: #d97706;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-box p {
            font-size: 1em;
            line-height: 1.3;
            color: #78716c;
            margin-bottom: 6px;
        }

        .info-box .example-section {
            margin-top: 12px;
            font-style: italic;
            background: rgba(255,255,255,0.7);
            padding: 12px;
            border-radius: 8px;
        }

        .info-box .example-section p {
            margin-bottom: 2px;
        }

        .btn-toggle-info {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 6px 14px;
            font-size: 0.85em;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-toggle-info:hover {
            box-shadow: 0 3px 10px rgba(245, 158, 11, 0.4);
            transform: translateY(-1px);
        }

        .image-upload-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .image-preview {
            width: 95px;
            height: 95px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: #f9fafb;
        }

        .image-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .image-preview.has-image {
            border: 2px solid #10b981;
            background: white;
        }

        .btn-add-image {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 8px 16px;
            font-size: 0.95em;
        }

        .btn-add-image:hover {
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4);
        }

        .btn-remove-image {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 6px 12px;
            font-size: 0.85em;
        }

        .btn-remove-image:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4);
        }

        .duty-row, .ks-row, .behavior-row {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #7dd3fc;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .duty-header, .ks-header, .behavior-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .task-list, .ks-list, .behavior-list {
            margin-left: 20px;
        }

        .task-item, .ks-item, .behavior-item {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            align-items: center;
        }

        .task-label, .ks-label, .behavior-label {
            width: 90px;
            color: #666;
            flex-shrink: 0;
            font-weight: 600;
            font-size: 1.05em;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .copyright {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
            color: #7f8c8d;
            font-size: 1.05em;
        }

        .mb-10 {
            margin-bottom: 10px;
        }

        .mb-20 {
            margin-bottom: 20px;
        }

        .icon {
            margin-right: 8px;
        }

        .hidden {
            display: none;
        }

        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 3px solid #e0e0e0;
            gap: 10px;
        }

        .tab {
            padding: 15px 30px;
            cursor: pointer;
            border: none;
            background: #f5f5f5;
            border-radius: 12px 12px 0 0;
            font-size: 1.15em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }

        .tab:hover {
            background: #e0e0e0;
            color: #333;
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            transform: translateY(3px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .two-column {
            display: flex;
            gap: 25px;
        }

        .column {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
            font-size: 1.1em;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        .status {
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            font-size: 1.05em;
            font-weight: 600;
            text-align: center;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
            border: 2px solid #10b981;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
            border: 2px solid #ef4444;
        }

        .section-container {
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .section-header-editable {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-header-editable h3 {
            margin: 0;
            padding: 8px 12px;
            border-radius: 6px;
            transition: background 0.3s;
        }

        .section-header-editable h3[contenteditable="true"] {
            background: #fff;
            border: 2px solid #667eea;
            outline: none;
            cursor: text;
        }

        .btn-rename {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 8px 16px;
            font-size: 0.95em;
        }

        .btn-rename:hover {
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.4);
        }

        .btn-clear-section {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 8px 16px;
            font-size: 0.95em;
        }

        .btn-clear-section:hover {
            box-shadow: 0 5px 15px rgba(239, 68, 68, 0.4);
        }

        .btn-format {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 8px 16px;
            font-size: 0.95em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-format:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4);
        }

        .btn-ai-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3) !important;
        }

        /* Loading Modal */
        .loading-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .loading-modal.active {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-content {
            background: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid #f3f3f3;
            border-top: 6px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-content h3 {
            color: #667eea;
            margin: 0 0 10px 0;
            font-size: 1.3em;
        }

        .loading-content p {
            color: #666;
            margin: 0;
            font-size: 1em;
        }

        /* Usage Limit Badge */
        .usage-badge {
            display: inline-block;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 10px;
        }

        .usage-badge.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .usage-badge.limit {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        /* Task Verification Tab Styles */
        .verification-mode-selector {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
        }

        .verification-mode-selector h3 {
            color: white;
            margin: 0 0 15px 0;
        }

        .mode-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-option {
            background: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mode-option input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .mode-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .mode-option label {
            cursor: pointer;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .duty-accordion {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            margin-bottom: 15px;
            overflow: hidden;
            transition: all 0.3s;
        }

        .duty-accordion:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
        }

        .duty-accordion-header {
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            padding: 18px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
        }

        .duty-accordion-header:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .duty-accordion-header.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-color: #5a67d8;
        }

        .duty-title {
            font-size: 1.1em;
            font-weight: 600;
            flex: 1;
        }

        .duty-toggle {
            font-size: 1.3em;
            transition: transform 0.3s;
        }

        .duty-accordion-header.active .duty-toggle {
            transform: rotate(180deg);
        }

        .duty-accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
        }

        .duty-accordion-content.active {
            max-height: 5000px;
            transition: max-height 0.5s ease-in;
        }

        .verification-table {
            width: 100%;
            min-width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        /* Extended mode requires more width - enable horizontal scroll */
        .workflow-extended .verification-table {
            min-width: 1400px;
        }

        .verification-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            font-size: 0.95em;
        }

        .verification-table th:first-child {
            border-top-left-radius: 8px;
        }

        .verification-table th:last-child {
            border-top-right-radius: 8px;
        }

        .verification-table td {
            padding: 15px 12px;
            border-bottom: 1px solid #e5e7eb;
        }

        .verification-table tr:last-child td {
            border-bottom: none;
        }

        .verification-table tr:hover {
            background: #f9fafb;
        }

        .task-text {
            font-weight: 500;
            color: #333;
            line-height: 1.4;
        }

        .rating-scale {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .rating-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .rating-option input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .rating-option label {
            font-size: 0.85em;
            color: #666;
            font-weight: 600;
            cursor: pointer;
        }

        .no-duties-message {
            text-align: center;
            padding: 60px 20px;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-radius: 12px;
            margin: 30px 0;
        }

        .no-duties-message h3 {
            color: #92400e;
            margin: 0 0 10px 0;
        }

        .no-duties-message p {
            color: #78350f;
            margin: 0;
        }

        .verification-instructions {
            background: #eff6ff;
            border-left: 4px solid #3b82f6;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .verification-instructions h4 {
            color: #1e40af;
            margin: 0 0 8px 0;
            font-size: 1.05em;
        }

        .verification-instructions p {
            color: #1e3a8a;
            margin: 0;
            line-height: 1.5;
            font-size: 0.95em;
        }

        /* Rating Scale Labels */
        .scale-legend {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .scale-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scale-legend-label {
            font-weight: 600;
            color: #667eea;
        }

        .scale-legend-values {
            color: #666;
            font-size: 0.9em;
        }

        /* Extended Mode - Additional Fields */
        .performs-task-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .performs-task-toggle label {
            font-weight: 600;
            margin: 0;
        }

        .performs-task-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Completion Indicator */
        .completion-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .completion-indicator.complete {
            background: #d1fae5;
            color: #065f46;
        }

        .completion-indicator.incomplete {
            background: #fee2e2;
            color: #991b1b;
        }

        /* Priority Level Badge */
        .priority-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .priority-badge.high {
            background: #fee2e2;
            color: #991b1b;
        }

        .priority-badge.medium {
            background: #fed7aa;
            color: #92400e;
        }

        .priority-badge.low {
            background: #dbeafe;
            color: #1e40af;
        }

        /* Score Display */
        .score-display {
            font-weight: 600;
            font-size: 1.1em;
            color: #667eea;
        }

        /* Comments Textarea */
        .task-comments {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.9em;
            font-family: inherit;
            resize: vertical;
        }

        .task-comments:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Extended mode visibility */
        .extended-only {
            display: none;
        }

        .workflow-extended .extended-only {
            display: table-cell;
        }

        .workflow-extended .scale-legend .extended-only {
            display: flex;
        }

        /* ============ WORKSHOP AGGREGATED COUNTS CSS ============ */
        
        /* Workshop Participant Count Field */
        .workshop-participants {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
        }

        .workshop-participants h3 {
            color: white;
            margin: 0 0 15px 0;
        }

        .workshop-participants input {
            width: 150px;
            padding: 10px;
            font-size: 1.2em;
            text-align: center;
            border: 2px solid white;
            border-radius: 8px;
            font-weight: bold;
        }

        /* Count Input Grid */
        .count-input-grid {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        .count-input-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .count-input-item label {
            font-weight: 600;
            color: #667eea;
            font-size: 0.9em;
        }

        .count-input-item input {
            width: 50px;
            height: 40px;
            text-align: center;
            font-size: 1.1em;
            font-weight: 600;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .count-input-item input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .count-input-item input:invalid {
            border-color: #ef4444;
        }

        /* Validation Warning */
        /* Validation Messages: Error (red/blocking) and Warning (yellow/non-blocking) */
        .validation-warning {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
            padding: 10px 15px;
            margin-top: 10px;
            border-radius: 6px;
            display: none;
        }

        .validation-warning.show {
            display: block;
        }

        /* Error state: Red (blocking) - sum > participants */
        .validation-warning.error {
            background: #fef2f2;
            border-left: 4px solid #dc2626;
        }

        .validation-warning.error p {
            color: #991b1b;
            font-size: 0.9em;
            font-weight: 600;
            margin: 0;
        }

        /* Warning state: Yellow (non-blocking) - sum < participants */
        .validation-warning.warning {
            background: #fefce8;
            border-left: 4px solid #eab308;
        }

        .validation-warning.warning p {
            color: #854d0e;
            font-size: 0.9em;
            font-weight: 600;
            margin: 0;
        }

        .validation-warning p {
            margin: 0;
            color: #991b1b;
            font-size: 0.9em;
            font-weight: 600;
        }

        /* Weighted Mean Display */
        .weighted-mean {
            font-weight: 600;
            color: #10b981;
            font-size: 1em;
        }

        /* Priority Formula Selector */
        .priority-formula-selector {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .priority-formula-selector h4 {
            margin: 0 0 15px 0;
            color: #667eea;
        }

        .formula-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .formula-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .formula-option:hover {
            border-color: #667eea;
            background: #f9fafb;
        }

        .formula-option input[type="radio"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .formula-option label {
            cursor: pointer;
            font-weight: 600;
            margin: 0;
        }

        /* Results Dashboard */
        .results-dashboard {
            background: white;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 0;
            margin: 30px 0;
            overflow: hidden;
        }

        .results-dashboard-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }

        .results-dashboard-header:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b3fa8 100%);
        }

        .results-dashboard-header h3 {
            color: white;
            margin: 0;
            font-size: 1.3em;
        }

        .results-dashboard-toggle {
            color: white;
            font-size: 1.5em;
            transition: transform 0.3s;
        }

        .results-dashboard-header.active .results-dashboard-toggle {
            transform: rotate(180deg);
        }

        .results-dashboard-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
        }

        .results-dashboard-content.active {
            max-height: 5000px;
            transition: max-height 0.5s ease-in;
        }

        .results-dashboard-inner {
            padding: 20px;
        }

        /* Dashboard Summary Stats */
        .dashboard-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .summary-card h4 {
            margin: 0 0 5px 0;
            color: #667eea;
            font-size: 0.9em;
        }

        .summary-card p {
            margin: 0;
            font-size: 1.5em;
            font-weight: 600;
            color: #333;
        }

        /* Dashboard Table */
        .dashboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .dashboard-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .dashboard-table td {
            padding: 12px;
            border-bottom: 1px solid #e5e7eb;
        }

        .dashboard-table tr:hover {
            background: #f9fafb;
        }

        .dashboard-table tr.high-priority {
            background: #fef2f2;
            font-weight: 600;
        }

        .dashboard-table tr.high-priority td {
            border-bottom-color: #fecaca;
        }

        /* Rank Badge */
        .rank-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            background: #667eea;
            color: white;
        }

        .rank-badge.top {
            background: #ef4444;
        }

        /* Priority Index Display */
        .priority-index {
            font-weight: 600;
            font-size: 1.1em;
            color: #667eea;
        }

        /* Mean Value Display */
        .mean-value {
            font-weight: 600;
            color: #10b981;
        }

        /* Export Dashboard Button */
        .btn-export-dashboard {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            margin-top: 20px;
        }

        .btn-export-dashboard:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
        }

        /* Clustering Styles */
        .clustering-section {
            background: #f9fafb;
            padding: 25px;
            border-radius: 12px;
            border: 2px solid #e5e7eb;
            margin-bottom: 30px;
        }

        .clustering-section h3 {
            color: #667eea;
            margin: 0 0 20px 0;
            font-size: 1.3em;
        }

        .available-tasks-list {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .task-checkbox-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-bottom: 1px solid #f3f4f6;
            transition: background 0.2s;
        }

        .task-checkbox-item:hover {
            background: #f9fafb;
        }

        .task-checkbox-item:last-child {
            border-bottom: none;
        }

        .task-checkbox-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .task-checkbox-label {
            flex: 1;
            cursor: pointer;
            color: #333;
            line-height: 1.5;
        }

        .task-priority-badge {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .btn-create-cluster {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 14px 30px;
            font-size: 1.05em;
            margin: 20px 0;
            display: block;
            width: 100%;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }

        .btn-create-cluster:disabled {
            background: #d1d5db;
            cursor: not-allowed;
            transform: none;
        }

        .btn-create-cluster:disabled:hover {
            box-shadow: none;
            transform: none;
        }

        .clusters-container {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
        }

        .cluster-item {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #7dd3fc;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .cluster-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #7dd3fc;
        }

        .cluster-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #0369a1;
        }

        .cluster-actions {
            display: flex;
            gap: 10px;
        }

        .btn-rename-cluster {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .btn-delete-cluster {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .cluster-tasks-list {
            margin-top: 15px;
        }

        .cluster-task-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid #e0f2fe;
        }

        .cluster-task-text {
            flex: 1;
            color: #333;
            line-height: 1.5;
        }

        .btn-remove-task {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-remove-task:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        .no-tasks-message {
            text-align: center;
            padding: 40px;
            color: #999;
            font-style: italic;
        }

        .no-clusters-message {
            text-align: center;
            padding: 40px;
            color: #999;
            font-style: italic;
        }

        .task-reassign-dropdown {
            padding: 6px 10px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            color: #333;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 150px;
        }

        .task-reassign-dropdown:hover {
            border-color: #667eea;
        }

        .task-reassign-dropdown:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .task-dropdown-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
        }

        .task-dropdown-label {
            font-size: 0.85em;
            color: #666;
            font-weight: 600;
        }

        .btn-bypass-verification {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“Š DACUM Live Pro <span style="font-size: 0.5em; color: #667eea; font-weight: normal;">v5.0</span></h1>
        <p style="text-align: center; color: #667eea; font-size: 0.95em; margin: -10px 0 20px 0; font-style: italic;">Execution, Verification, Evidence</p>
        
        <div class="info-box" id="infoBox">
            <h3>
                ğŸ¯ How to Use This Tool
                <button class="btn-toggle-info" onclick="toggleInfoBox()">Hide</button>
            </h3>
            <div id="infoBoxContent">
                <p><strong>1.</strong> Enter the occupation title and job title in Chart Info tab</p>
                <p><strong>2.</strong> Use AI Generation (in Duties & Tasks tab) OR add duties and tasks manually</p>
                <p><strong>3.</strong> Add knowledge, skills, and behaviors (optional)</p>
                <p><strong>4.</strong> Optionally verify tasks in Task Verification tab using workshop voting or individual ratings</p>
                <p><strong>5.</strong> Export as PDF or Word document</p>
                
                <div class="example-section">
                    <p><strong>ğŸ¤– AI-Powered:</strong> Automatically generate complete DACUM drafts with duties and tasks</p>
                    <p><strong>ğŸ“ Format for tasks:</strong> Action Verb + Task/Activity (What) + Context (Where/How/Why if relevant)</p>
                    <p><strong>ğŸ’¡ Example:</strong> "Calibrate testing equipment according to manufacturer specifications"</p>
                </div>
            </div>
        </div>
        
        <div class="tabs">
            <div class="tab active" data-tab="info-tab">ğŸ“‹ Chart Info</div>
            <div class="tab" data-tab="duties-tab">âœ… Duties & Tasks</div>
            <div class="tab" data-tab="additional-info-tab">ğŸ“š Additional Info</div>
            <div class="tab" data-tab="verification-tab">ğŸ¯ Task Verification</div>
            <div class="tab" data-tab="clustering-tab">ğŸ¯ Competency Clusters</div>
            <div class="tab" data-tab="contact-tab">ğŸ“ Contact</div>
        </div>
        
        <div class="tab-content active" id="info-tab">
            <h2>DACUM Research Chart Information</h2>
            
            <div class="mb-20">
                <div class="mb-10">
                    <label for="dacumDate">ğŸ“… DACUM Date:</label>
                    <input type="date" id="dacumDate" style="cursor: pointer;">
                </div>
                
                <div class="mb-10">
                    <label for="producedFor">ğŸ¢ Produced For:</label>
                    <input type="text" id="producedFor" placeholder="e.g., Company/Organization Name">
                    <div class="image-upload-container">
                        <div class="image-preview" id="producedForImagePreview">
                            <span style="color: #999; font-size: 0.9em;">No image</span>
                        </div>
                        <div>
                            <button class="btn-add-image" onclick="document.getElementById('producedForImageInput').click()">
                                ğŸ–¼ï¸ Add Logo
                            </button>
                            <button class="btn-remove-image" id="removeProducedForImage" onclick="removeImage('producedFor')" style="display: none;">
                                ğŸ—‘ï¸ Remove
                            </button>
                            <input type="file" id="producedForImageInput" accept=".jpg,.jpeg,.png,.bmp" style="display: none;" onchange="handleImageUpload(event, 'producedFor')">
                        </div>
                    </div>
                </div>
                
                <div class="mb-10">
                    <label for="producedBy">ğŸ“ Produced By:</label>
                    <input type="text" id="producedBy" placeholder="e.g., Training Institution Name">
                    <div class="image-upload-container">
                        <div class="image-preview" id="producedByImagePreview">
                            <span style="color: #999; font-size: 0.9em;">No image</span>
                        </div>
                        <div>
                            <button class="btn-add-image" onclick="document.getElementById('producedByImageInput').click()">
                                ğŸ–¼ï¸ Add Logo
                            </button>
                            <button class="btn-remove-image" id="removeProducedByImage" onclick="removeImage('producedBy')" style="display: none;">
                                ğŸ—‘ï¸ Remove
                            </button>
                            <input type="file" id="producedByImageInput" accept=".jpg,.jpeg,.png,.bmp" style="display: none;" onchange="handleImageUpload(event, 'producedBy')">
                        </div>
                    </div>
                </div>
                
                <div class="mb-10">
                    <label for="occupationTitle">ğŸ’¼ Occupation Title:</label>
                    <input type="text" id="occupationTitle" placeholder="e.g., Automotive Technician">
                </div>
                
                <div class="mb-10">
                    <label for="jobTitle">ğŸ‘” Job Title:</label>
                    <input type="text" id="jobTitle" placeholder="e.g., Service Technician Level 2">
                </div>
                
                <div class="mb-10">
                    <label for="sector">ğŸ­ Sector (Optional):</label>
                    <input type="text" id="sector" placeholder="e.g., Automotive, Healthcare, IT">
                </div>
                
                <div class="mb-10">
                    <label for="context">ğŸŒ Country / Context (Optional):</label>
                    <input type="text" id="context" placeholder="e.g., Iraq, Middle East">
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="duties-tab">
            <h2>Duties and Tasks</h2>
            
            <!-- AI Generation Section -->
            <div style="margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; text-align: center;">
                <h3 style="color: white; margin: 0 0 10px 0; font-size: 1.1em;">âœ¨ AI-Powered DACUM Generation</h3>
                <p style="color: rgba(255,255,255,0.9); margin: 0 0 15px 0; font-size: 0.95em;">Generate complete duties and tasks automatically based on occupation details</p>
                <button class="btn-ai-generate" id="aiGenerateBtn" onclick="generateAIDacum()" style="background: white; color: #667eea; padding: 12px 30px; font-size: 1.05em; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
                    ğŸ¤– Generate AI Draft
                </button>
                <div id="usageBadge" class="usage-badge" style="display: none;">
                    <!-- Usage info will be shown here -->
                </div>
                <p style="color: rgba(255,255,255,0.8); margin: 15px 0 0 0; font-size: 0.85em;">ğŸ’¡ Make sure to fill Occupation Title and Job Title in Chart Info tab first</p>
            </div>
            
            <div id="dutiesContainer"></div>
            <button class="btn-add" onclick="addDuty()">â• Add Duty</button>
        </div>
        
        <div class="tab-content" id="additional-info-tab">
            <h2>Additional Information</h2>
            <p style="color: #666; margin-bottom: 25px; font-size: 1.05em;">ğŸ“ Enter information for each section. Click the rename button to customize section headings.</p>
            
            <div class="section-container">
                <div class="section-header-editable">
                    <h3 id="knowledgeHeading" contenteditable="false">Knowledge Requirements</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-format" onclick="formatList('knowledgeInput', 'number')" title="Add numbering">ğŸ”¢ Number</button>
                        <button class="btn-format" onclick="formatList('knowledgeInput', 'bullet')" title="Add bullets">â€¢ Bullet</button>
                        <button class="btn-rename" onclick="toggleEditHeading('knowledgeHeading')">âœï¸ Rename</button>
                        <button class="btn-clear-section" onclick="clearSection('knowledgeInput', 'knowledgeHeading', 'Knowledge Requirements')">ğŸ—‘ï¸ Clear</button>
                    </div>
                </div>
                <textarea id="knowledgeInput" placeholder="Enter each knowledge requirement on a new line&#10;Example:&#10;â€¢ Understanding of electrical systems&#10;â€¢ Knowledge of safety protocols&#10;â€¢ Familiarity with diagnostic tools"></textarea>
            </div>
            
            <div class="section-container">
                <div class="section-header-editable">
                    <h3 id="skillsHeading" contenteditable="false">Skills Requirements</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-format" onclick="formatList('skillsInput', 'number')" title="Add numbering">ğŸ”¢ Number</button>
                        <button class="btn-format" onclick="formatList('skillsInput', 'bullet')" title="Add bullets">â€¢ Bullet</button>
                        <button class="btn-rename" onclick="toggleEditHeading('skillsHeading')">âœï¸ Rename</button>
                        <button class="btn-clear-section" onclick="clearSection('skillsInput', 'skillsHeading', 'Skills Requirements')">ğŸ—‘ï¸ Clear</button>
                    </div>
                </div>
                <textarea id="skillsInput" placeholder="Enter each skill requirement on a new line&#10;Example:&#10;â€¢ Ability to read technical diagrams&#10;â€¢ Proficiency in using hand tools&#10;â€¢ Strong problem-solving skills"></textarea>
            </div>
            
            <div class="section-container">
                <div class="section-header-editable">
                    <h3 id="behaviorsHeading" contenteditable="false">Worker Behaviors/Traits</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-format" onclick="formatList('behaviorsInput', 'number')" title="Add numbering">ğŸ”¢ Number</button>
                        <button class="btn-format" onclick="formatList('behaviorsInput', 'bullet')" title="Add bullets">â€¢ Bullet</button>
                        <button class="btn-rename" onclick="toggleEditHeading('behaviorsHeading')">âœï¸ Rename</button>
                        <button class="btn-clear-section" onclick="clearSection('behaviorsInput', 'behaviorsHeading', 'Worker Behaviors/Traits')">ğŸ—‘ï¸ Clear</button>
                    </div>
                </div>
                <textarea id="behaviorsInput" placeholder="Enter each behavior or trait on a new line&#10;Example:&#10;â€¢ Attention to detail&#10;â€¢ Good communication skills&#10;â€¢ Team player&#10;â€¢ Safety conscious"></textarea>
            </div>
            
            <div class="section-container">
                <div class="section-header-editable">
                    <h3 id="toolsHeading" contenteditable="false">Tools, Equipment, Supplies and Materials</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-format" onclick="formatList('toolsInput', 'number')" title="Add numbering">ğŸ”¢ Number</button>
                        <button class="btn-format" onclick="formatList('toolsInput', 'bullet')" title="Add bullets">â€¢ Bullet</button>
                        <button class="btn-rename" onclick="toggleEditHeading('toolsHeading')">âœï¸ Rename</button>
                        <button class="btn-clear-section" onclick="clearSection('toolsInput', 'toolsHeading', 'Tools, Equipment, Supplies and Materials')">ğŸ—‘ï¸ Clear</button>
                    </div>
                </div>
                <textarea id="toolsInput" placeholder="Enter each tool/equipment on a new line&#10;Example:&#10;â€¢ Digital multimeter&#10;â€¢ Pneumatic impact wrench&#10;â€¢ Safety glasses&#10;â€¢ Hydraulic lift"></textarea>
            </div>
            
            <div class="section-container">
                <div class="section-header-editable">
                    <h3 id="trendsHeading" contenteditable="false">Future Trends and Concerns</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-format" onclick="formatList('trendsInput', 'number')" title="Add numbering">ğŸ”¢ Number</button>
                        <button class="btn-format" onclick="formatList('trendsInput', 'bullet')" title="Add bullets">â€¢ Bullet</button>
                        <button class="btn-rename" onclick="toggleEditHeading('trendsHeading')">âœï¸ Rename</button>
                        <button class="btn-clear-section" onclick="clearSection('trendsInput', 'trendsHeading', 'Future Trends and Concerns')">ğŸ—‘ï¸ Clear</button>
                    </div>
                </div>
                <textarea id="trendsInput" placeholder="Enter each trend/concern on a new line&#10;Example:&#10;â€¢ Increased use of electric vehicles&#10;â€¢ Advanced driver assistance systems&#10;â€¢ Sustainability requirements&#10;â€¢ Automation in manufacturing"></textarea>
            </div>
            
            <div class="section-container">
                <div class="section-header-editable">
                    <h3 id="acronymsHeading" contenteditable="false">Acronyms</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-format" onclick="formatList('acronymsInput', 'number')" title="Add numbering">ğŸ”¢ Number</button>
                        <button class="btn-format" onclick="formatList('acronymsInput', 'bullet')" title="Add bullets">â€¢ Bullet</button>
                        <button class="btn-rename" onclick="toggleEditHeading('acronymsHeading')">âœï¸ Rename</button>
                        <button class="btn-clear-section" onclick="clearSection('acronymsInput', 'acronymsHeading', 'Acronyms')">ğŸ—‘ï¸ Clear</button>
                    </div>
                </div>
                <textarea id="acronymsInput" placeholder="Enter acronyms and their definitions on separate lines&#10;Example:&#10;â€¢ OBD - On-Board Diagnostics&#10;â€¢ ECU - Engine Control Unit&#10;â€¢ TPMS - Tire Pressure Monitoring System&#10;â€¢ ABS - Anti-lock Braking System"></textarea>
            </div>
            
            <div class="section-container">
                <div class="section-header-editable">
                    <h3 id="careerPathHeading" contenteditable="false">Career Path</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-format" onclick="formatList('careerPathInput', 'number')" title="Add numbering">ğŸ”¢ Number</button>
                        <button class="btn-format" onclick="formatList('careerPathInput', 'bullet')" title="Add bullets">â€¢ Bullet</button>
                        <button class="btn-rename" onclick="toggleEditHeading('careerPathHeading')">âœï¸ Rename</button>
                        <button class="btn-clear-section" onclick="clearSection('careerPathInput', 'careerPathHeading', 'Career Path')">ğŸ—‘ï¸ Clear</button>
                    </div>
                </div>
                <textarea id="careerPathInput" placeholder="Enter career progression information on separate lines&#10;Example:&#10;â€¢ Entry Level: Technician Apprentice&#10;â€¢ Mid Level: Certified Technician&#10;â€¢ Advanced: Senior Technician / Specialist&#10;â€¢ Management: Shop Foreman / Service Manager"></textarea>
            </div>
            
            <!-- Container for custom sections -->
            <div id="customSectionsContainer"></div>
            
            <!-- Add Section Button -->
            <div style="margin-top: 20px; text-align: center;">
                <button class="btn-add" onclick="addCustomSection()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 12px 24px; font-size: 1.05em;">
                    â• Add Section
                </button>
            </div>
        </div>
        
        <div class="tab-content" id="verification-tab">
            <h2>ğŸ¯ Task Verification & Training Priority</h2>
            
            <!-- Instructions -->
            <div class="verification-instructions">
                <h4>ğŸ“‹ Instructions:</h4>
                <p>Rate each task on three scales (0-3). Select the data collection mode first, then expand each duty to rate its tasks. Your ratings will be saved with the DACUM chart data.</p>
                <p style="margin-top: 15px;"><strong>Rating Scales:</strong><br>
                â€¢ <strong>Importance:</strong> 0=Not Important, 1=Somewhat, 2=Important, 3=Critical<br>
                â€¢ <strong>Frequency:</strong> 0=Rarely, 1=Sometimes, 2=Often, 3=Daily<br>
                â€¢ <strong>Difficulty:</strong> 0=Easy, 1=Moderate, 2=Challenging, 3=Very Difficult</p>
            </div>
            
            <!-- Data Collection Mode Selector -->
            <div class="verification-mode-selector">
                <h3>ğŸ“Š Data Collection Mode</h3>
                <div class="mode-options">
                    <div class="mode-option">
                        <input type="radio" id="mode-workshop" name="collectionMode" value="workshop" checked onchange="updateCollectionMode()">
                        <label for="mode-workshop">ğŸ‘¥ Workshop (Facilitated)</label>
                    </div>
                    <div class="mode-option">
                        <input type="radio" id="mode-survey" name="collectionMode" value="survey" onchange="updateCollectionMode()">
                        <label for="mode-survey">ğŸ“ Individual / Survey</label>
                    </div>
                </div>
            </div>
            
            <!-- Workflow Mode Selector -->
            <div class="verification-mode-selector" style="margin-top: 20px;">
                <h3>âš™ï¸ Workflow Mode</h3>
                <div class="mode-options">
                    <div class="mode-option">
                        <input type="radio" id="workflow-standard" name="workflowMode" value="standard" checked onchange="updateWorkflowMode()">
                        <label for="workflow-standard">ğŸ“Š Standard (DACUM)</label>
                    </div>
                    <div class="mode-option">
                        <input type="radio" id="workflow-extended" name="workflowMode" value="extended" onchange="updateWorkflowMode()">
                        <label for="workflow-extended">ğŸ“ˆ Extended (DACUM)</label>
                    </div>
                </div>
            </div>
            
            <!-- Workshop Participants Count (Workshop mode only) -->
            <div class="workshop-participants" id="workshopParticipantsSection" style="display: none;">
                <h3>ğŸ‘¥ Number of Workshop Participants</h3>
                <input type="number" id="workshopParticipants" min="1" max="50" value="10" onchange="updateParticipantCount()">
                <p style="color: white; margin: 10px 0 0 0; font-size: 0.9em;">
                    Enter the total number of workshop participants (recommended: 8â€“20). This is the maximum number of responses per task.
                </p>
            </div>
            
            <!-- Priority Formula Selector (Standard mode only) -->
            <div class="priority-formula-selector" id="priorityFormulaSection" style="display: none;">
                <h4>ğŸ“ Priority Calculation Formula</h4>
                <div class="formula-options">
                    <div class="formula-option">
                        <input type="radio" id="formula-if" name="priorityFormula" value="if" checked onchange="updatePriorityFormula()">
                        <label for="formula-if">Importance Ã— Frequency</label>
                    </div>
                    <div class="formula-option">
                        <input type="radio" id="formula-ifd" name="priorityFormula" value="ifd" onchange="updatePriorityFormula()">
                        <label for="formula-ifd">Importance Ã— Frequency Ã— Difficulty</label>
                    </div>
                </div>
                <p style="margin: 10px 0 0 0; color: #666; font-size: 0.9em;">
                    Select the formula to calculate Priority Index for training priority ranking.
                </p>
            </div>
            
            <!-- Duties and Tasks Accordion Container -->
            <div id="verificationAccordionContainer">
                <!-- Will be populated dynamically -->
            </div>
            
            <!-- Results Dashboard (Workshop Mode Only) -->
            <div class="results-dashboard" id="resultsDashboard" style="display: none;">
                <div class="results-dashboard-header" onclick="toggleDashboard()">
                    <h3>ğŸ“Š Workshop Results Dashboard</h3>
                    <div class="results-dashboard-toggle">â–¼</div>
                </div>
                <div class="results-dashboard-content" id="dashboardContent">
                    <div class="results-dashboard-inner">
                        <!-- Summary Statistics -->
                        <div class="dashboard-summary" id="dashboardSummary">
                            <!-- Will be populated dynamically -->
                        </div>
                        
                        <!-- Results Table -->
                        <div style="overflow-x: auto;">
                            <table class="dashboard-table" id="dashboardTable">
                                <thead>
                                    <tr>
                                        <th>Rank</th>
                                        <th>Duty</th>
                                        <th>Task</th>
                                        <th>Mean<br>Importance</th>
                                        <th>Mean<br>Frequency</th>
                                        <th>Mean<br>Difficulty</th>
                                        <th>Priority<br>Index</th>
                                    </tr>
                                </thead>
                                <tbody id="dashboardTableBody">
                                    <!-- Will be populated dynamically -->
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Duty-Level Summary Section -->
                        <div style="margin-top: 30px; border-top: 2px solid #e5e7eb; padding-top: 20px;">
                            <div class="duty-level-header" onclick="toggleDutyLevelSummary()" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 15px; background: #f9fafb; border-radius: 8px; margin-bottom: 15px;">
                                <h4 style="margin: 0; color: #667eea; font-size: 1.1em;">ğŸ“‹ Duty-Level Summary</h4>
                                <div id="dutyLevelToggle" style="font-size: 1.2em; color: #667eea;">â–¼</div>
                            </div>
                            <div id="dutyLevelContent" style="display: block;">
                                <!-- Training Load Method Selector -->
                                <div style="margin-bottom: 20px; padding: 15px; background: #f0f7ff; border-radius: 8px; border: 2px solid #667eea;">
                                    <h5 style="margin: 0 0 10px 0; color: #333; font-size: 1em;">Training Load Calculation Method:</h5>
                                    <div style="display: flex; flex-direction: column; gap: 10px;">
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                            <input type="radio" name="trainingLoadMethod" value="advanced" checked onchange="updateTrainingLoadMethod()" style="width: 16px; height: 16px;">
                                            <span style="font-weight: 600;">Advanced</span> â€” Î£ (Priority Index Ã— Mean Difficulty) <span style="color: #667eea; font-style: italic;">(Recommended)</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                            <input type="radio" name="trainingLoadMethod" value="simple" onchange="updateTrainingLoadMethod()" style="width: 16px; height: 16px;">
                                            <span style="font-weight: 600;">Simple</span> â€” Average Priority Ã— Tasks Count
                                        </label>
                                    </div>
                                    <div id="trainingLoadMethodLabel" style="margin-top: 10px; padding: 8px; background: white; border-radius: 4px; font-size: 0.9em; color: #666;">
                                        Current Method: <strong style="color: #667eea;">Advanced</strong>
                                    </div>
                                </div>
                                
                                <!-- Sort Selector -->
                                <div style="margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                                    <label style="font-weight: 600; color: #333;">Sort By:</label>
                                    <select id="dutySortSelector" onchange="updateDutyLevelSummary()" style="padding: 8px; border: 2px solid #e5e7eb; border-radius: 4px; font-size: 0.9em;">
                                        <option value="priority">Average Priority Index</option>
                                        <option value="trainingLoad">Training Load Score</option>
                                    </select>
                                </div>
                                
                                <!-- Duty-Level Table -->
                                <div style="overflow-x: auto;">
                                    <table class="dashboard-table" id="dutyLevelTable">
                                        <thead>
                                            <tr>
                                                <th>Duty Title</th>
                                                <th>Total<br>Tasks</th>
                                                <th>Valid<br>Tasks</th>
                                                <th>Avg Mean<br>Importance</th>
                                                <th>Avg Mean<br>Frequency</th>
                                                <th>Avg Mean<br>Difficulty</th>
                                                <th>Avg Priority<br>Index</th>
                                                <th>High Priority<br>Tasks</th>
                                                <th>Training Load<br>Score</th>
                                            </tr>
                                        </thead>
                                        <tbody id="dutyLevelTableBody">
                                            <!-- Will be populated dynamically -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Export Button -->
                        <div style="text-align: center;">
                            <button class="btn-export-dashboard" onclick="exportDashboard()">
                                ğŸ“Š Export Dashboard as CSV
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Load Duties Button -->
            <div style="text-align: center; margin: 30px 0;">
                <button class="btn-add" onclick="loadDutiesForVerification()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 30px; font-size: 1.05em;">
                    ğŸ”„ Refresh Duties & Tasks
                </button>
                <p style="color: #666; margin-top: 10px; font-size: 0.9em;">Click to reload duties and tasks from the Duties & Tasks tab</p>
            </div>
            
            <!-- ===== LIVE WORKSHOP MODULE (MVP INTEGRATION) ===== -->
            <div id="liveWorkshopSection" style="display: none; margin-top: 40px; padding-top: 40px; border-top: 3px solid #667eea;">
                <h2 style="color: #667eea; text-align: center; margin-bottom: 20px;">ğŸ¯ Live Workshop Voting System</h2>
                
                <!-- Step 1: Finalize for Live Workshop -->
                <div id="lwStep1-finalize" style="margin: 30px 0;">
                    <div style="background: linear-gradient(135deg, #f0f7ff 0%, #e0f2fe 100%); padding: 25px; border-radius: 12px; border: 2px solid #667eea; margin-bottom: 20px;">
                        <h3 style="color: #667eea; margin: 0 0 15px 0;">ğŸ“‹ Ready to Start Live Voting?</h3>
                        <p style="color: #334155; margin: 0 0 15px 0; line-height: 1.6;">
                            Finalize your duties and tasks to create a live voting session. After finalization:
                        </p>
                        <ul style="color: #334155; margin: 0 0 15px 0; padding-left: 25px; line-height: 1.8;">
                            <li>âœ… Duties and tasks will be <strong>locked</strong> (read-only)</li>
                            <li>âœ… A unique <strong>participant link</strong> will be generated</li>
                            <li>âœ… Participants can vote on all tasks (0-3 scales)</li>
                            <li>âœ… Results will be <strong>aggregated</strong> and ranked by priority</li>
                        </ul>
                        <p style="color: #64748b; margin: 0; font-size: 0.9em; font-style: italic;">
                            <strong>Note:</strong> Make sure all duties and tasks are complete before finalizing.
                        </p>
                    </div>
                    
                    <div style="text-align: center;">
                        <button class="btn-primary" onclick="lwFinalizeAndCreateSession()" id="btnLWFinalize" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px 40px; font-size: 1.1em; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            ğŸ”’ Finalize & Create Live Voting Session
                        </button>
                        <button class="btn-bypass-verification" onclick="bypassToClusteringTab()" id="btnBypassToClustering" style="margin-left: 15px;">
                            âš¡ Proceed to Competency Clustering Without Verification
                        </button>
                    </div>
                </div>

                <!-- Step 2: Session Active (Hidden until session created) -->
                <div id="lwStep2-session" style="display: none; margin: 30px 0;">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <span style="background: #10b981; color: white; padding: 10px 20px; border-radius: 25px; font-weight: 600; font-size: 1.1em; display: inline-block;">
                            âœ… FINALIZED & LOCKED
                        </span>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 30px; border-radius: 12px; margin: 20px 0; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);">
                        <h3 style="color: white; margin: 0 0 15px 0; font-size: 1.3em;">ğŸ“¢ Live Voting Session Active</h3>
                        <p style="margin: 0 0 20px 0; opacity: 0.95;">Share this link with participants to start voting:</p>
                        <div id="lwParticipantLink" style="background: white; color: #10b981; padding: 15px 20px; border-radius: 8px; font-family: monospace; font-size: 1em; word-break: break-all; margin: 0 0 15px 0; font-weight: 600;"></div>
                        <button class="btn-success" onclick="lwCopyLink()" style="background: white; color: #10b981; border: 2px solid white; padding: 12px 24px; font-weight: 600; border-radius: 8px; cursor: pointer;">
                            ğŸ“‹ Copy Link to Clipboard
                        </button>
                        <p style="margin: 20px 0 0 0; font-size: 0.9em; opacity: 0.9;">
                            Session ID: <span id="lwSessionId" style="font-family: monospace; font-weight: 600;"></span>
                        </p>
                    </div>

                    <div style="text-align: center; margin: 30px 0; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn-primary" onclick="lwFetchResults()" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; padding: 15px 40px; font-size: 1.1em; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            ğŸ”„ Refresh Voting Results
                        </button>
                        <button onclick="lwCloseVoting()" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 15px 40px; font-size: 1.1em; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            ğŸ”’ Close Voting (Lock Submissions)
                        </button>
                    </div>

                    <!-- Results Container -->
                    <div id="lwResultsContainer" style="margin-top: 30px;">
                        <!-- Results will be displayed here -->
                    </div>

                    <!-- Export Buttons (shown after results) -->
                    <div id="lwExportButtons" style="display: none; margin-top: 30px; padding: 25px; background: #f9fafb; border-radius: 12px; border: 2px solid #e5e7eb;">
                        <h3 style="color: #667eea; margin: 0 0 20px 0; text-align: center;">ğŸ“¥ Export Voting Results</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <button onclick="lwExportJSON()" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; padding: 15px 20px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em;">
                                ğŸ“„ Export JSON<br><span style="font-size: 0.85em; opacity: 0.9;">(With Voting Data)</span>
                            </button>
                            <button onclick="lwExportCSV()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 15px 20px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em;">
                                ğŸ“Š Export CSV<br><span style="font-size: 0.85em; opacity: 0.9;">(Tasks & Scores)</span>
                            </button>
                            <button onclick="lwExportSnapshot()" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 15px 20px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em;">
                                ğŸ’¾ Download Snapshot<br><span style="font-size: 0.85em; opacity: 0.9;">(Pre-Voting Backup)</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Task Verification Export Options -->
            <div style="max-width: 800px; margin: 30px auto 20px auto; padding: 20px; background: white; border: 2px solid #e5e7eb; border-radius: 12px;">
                <h3 style="color: #667eea; margin: 0 0 15px 0; font-size: 1.1em;">ğŸ“Š Task Verification Export Options</h3>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="radio" id="tvExportAppendix" name="tvExportMode" value="appendix" checked onchange="updateTVExportMode()" style="width: 18px; height: 18px; cursor: pointer;">
                        <span style="font-weight: 600; color: #333;">Include Task Verification in DACUM Report (Appendix)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="radio" id="tvExportStandalone" name="tvExportMode" value="standalone" onchange="updateTVExportMode()" style="width: 18px; height: 18px; cursor: pointer;">
                        <span style="font-weight: 600; color: #333;">Export Task Verification as Standalone Report</span>
                    </label>
                </div>
            </div>

        </div>
        
        <div class="tab-content" id="clustering-tab">
            <h2>ğŸ¯ Competency Clusters</h2>
            
            <!-- Available Tasks Section -->
            <div class="clustering-section">
                <h3>ğŸ“‹ Available Tasks</h3>
                <p style="color: #666; margin-bottom: 15px;">Select tasks to group into a cluster, then click "Create Cluster".</p>
                <div class="available-tasks-list" id="availableTasksList">
                    <div class="no-tasks-message">No tasks available. Please complete duties and tasks first.</div>
                </div>
                <button class="btn-create-cluster" id="btnCreateCluster" onclick="createCluster()" disabled>
                    âœ¨ Create Cluster
                </button>
            </div>

            <!-- Created Clusters Section -->
            <div class="clustering-section">
                <h3>ğŸ“¦ Created Clusters</h3>
                <div class="clusters-container" id="clustersContainer">
                    <div class="no-clusters-message">No clusters created yet.</div>
                </div>
            </div>
        </div>
        
        <div class="tab-content" id="contact-tab">
            <h2>ğŸ“ Contact & Support</h2>
            
            <div style="max-width: 700px; margin: 0 auto; padding: 30px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.15);">
                
                <div style="background: white; padding: 30px; border-radius: 12px; margin-bottom: 0;">
                    <div style="text-align: center; margin-bottom: 25px;">
                        <h3 style="color: #667eea; margin: 0 0 10px 0; font-size: 1.5em;">ğŸ‘¨â€ğŸ’» Husham Jawad Kadhim</h3>
                        <p style="color: #666; margin: 0; font-size: 1em; font-style: italic;">Creator of DACUM Live Pro</p>
                        <p style="color: #999; margin: 5px 0 0 0; font-size: 0.9em;">TVET Curriculum Developer & Educational Technology Innovator</p>
                    </div>
                    
                    <div style="border-top: 2px solid #f0f0f0; padding-top: 25px;">
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 12px;">
                                <span style="font-size: 1.5em;">ğŸ“§</span>
                                <div>
                                    <p style="margin: 0; font-weight: bold; color: #333; font-size: 0.9em;">Email</p>
                                    <a href="/cdn-cgi/l/email-protection#ea8299828b8b87ddddaa8d878b8386c4898587" style="color: #667eea; text-decoration: none; font-size: 1em;"><span class="__cf_email__" data-cfemail="e38b908b82828ed4d4a3848e828a8fcd808c8e">[email&#160;protected]</span></a>
                                </div>
                            </div>
                            
                            <div style="display: flex; align-items: center; gap: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                                <span style="font-size: 1.5em;">ğŸ’¼</span>
                                <div>
                                    <p style="margin: 0; font-weight: bold; color: #333; font-size: 0.9em;">LinkedIn</p>
                                    <a href="https://www.linkedin.com/in/husham-jawad-kadhim-954006200/" target="_blank" style="color: #667eea; text-decoration: none; font-size: 1em;">husham-jawad-kadhim-954006200</a>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background: #fff9e6; border-left: 4px solid #ffc107; padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <p style="margin: 0; color: #666; font-size: 0.95em; line-height: 1.6;">
                                <strong style="color: #333;">ğŸ’¡ Get in Touch:</strong><br>
                                For questions, feedback, suggestions, or collaboration opportunities, please reach out using the contact information above.
                            </p>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
        
        <div class="button-container">
            <button class="btn-save-data" onclick="saveToJSON()">
                ğŸ’¾ Save to JSON
            </button>
            <button class="btn-load-data" onclick="document.getElementById('loadFileInput').click()">
                ğŸ“ Load from JSON
            </button>
            <button class="btn-export" onclick="exportToPDF()">
                ğŸ“„ Export as PDF
            </button>
            <button class="btn-export-word" onclick="exportToWord()">
                ğŸ“ Export as Word (DOCX)
            </button>
            <button class="btn-clear-all" onclick="clearAll()">
                ğŸ—‘ï¸ Clear All
            </button>
        </div>
        
        <input type="file" id="loadFileInput" accept=".json" style="display: none;" onchange="loadFromJSON(event)">

        <div id="status" class="status" style="display:none;"></div>
        
        <div class="copyright">
            <p style="margin-bottom: 8px; font-size: 1em;">Â© 2025 DACUM Live Pro | by Husham Jawad Kadhim | Version 5.0 | All Rights Reserved</p>
            <p style="font-size: 0.85em; color: #999; font-style: italic;">
                <strong>Disclaimer:</strong> DACUM Live Pro is a facilitation and analysis tool provided "as is" without warranty of any kind. 
                The developer assumes no responsibility for any inaccuracies, errors, omissions, or inconsistencies in the generated documents. 
                Users and facilitating institutions are solely responsible for verifying, validating, and making final decisions on all content before use.
            </p>
        </div>
    </div>

    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        // Store uploaded images
        let producedForImage = null;
        let producedByImage = null;
        
        // Track custom sections
        let customSectionCounter = 0;

        // ============ USAGE LIMITING SYSTEM ============
        const DAILY_LIMIT = 10; // Maximum generations per user per day
        const STORAGE_KEY = 'dacum_ai_usage';

        function getUsageData() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (!stored) {
                return { count: 0, date: new Date().toDateString() };
            }
            return JSON.parse(stored);
        }

        function checkUsageLimit() {
            const usage = getUsageData();
            const today = new Date().toDateString();

            // Reset counter if it's a new day
            if (usage.date !== today) {
                const newUsage = { count: 0, date: today };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(newUsage));
                return { allowed: true, remaining: DAILY_LIMIT };
            }

            // Check if limit reached
            const remaining = DAILY_LIMIT - usage.count;
            return {
                allowed: remaining > 0,
                remaining: remaining,
                count: usage.count
            };
        }

        function incrementUsage() {
            const usage = getUsageData();
            const today = new Date().toDateString();

            if (usage.date !== today) {
                // New day, reset counter
                localStorage.setItem(STORAGE_KEY, JSON.stringify({ count: 1, date: today }));
            } else {
                // Increment counter
                usage.count++;
                localStorage.setItem(STORAGE_KEY, JSON.stringify(usage));
            }

            updateUsageBadge();
        }

        function updateUsageBadge() {
            const status = checkUsageLimit();
            const badge = document.getElementById('usageBadge');
            const btn = document.getElementById('aiGenerateBtn');

            if (status.remaining <= 0) {
                badge.innerHTML = `âŒ Daily limit reached (${DAILY_LIMIT}/${DAILY_LIMIT}) - Try again tomorrow`;
                badge.className = 'usage-badge limit';
                badge.style.display = 'inline-block';
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            } else if (status.remaining <= 3) {
                badge.innerHTML = `âš ï¸ ${status.remaining} generations remaining today`;
                badge.className = 'usage-badge warning';
                badge.style.display = 'inline-block';
            } else {
                badge.innerHTML = `âœ… ${status.remaining}/${DAILY_LIMIT} generations remaining today`;
                badge.className = 'usage-badge';
                badge.style.display = 'inline-block';
            }
        }

        // ============ LOADING MODAL FUNCTIONS ============
        function showLoadingModal() {
            const modal = document.getElementById('loadingModal');
            modal.style.display = 'flex';
        }

        function hideLoadingModal() {
            const modal = document.getElementById('loadingModal');
            modal.style.display = 'none';
        }

        // Initialize usage badge on page load
        window.addEventListener('DOMContentLoaded', function() {
            updateUsageBadge();
        });

        // Toggle info box visibility
        function toggleInfoBox() {
            const infoBoxContent = document.getElementById('infoBoxContent');
            const toggleButton = document.querySelector('.btn-toggle-info');
            
            if (infoBoxContent.style.display === 'none') {
                infoBoxContent.style.display = 'block';
                toggleButton.textContent = 'Hide';
            } else {
                infoBoxContent.style.display = 'none';
                toggleButton.textContent = 'Show';
            }
        }

        // Handle image upload
        function handleImageUpload(event, imageType) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/bmp'];
            if (!validTypes.includes(file.type)) {
                showStatus('Please upload a valid image file (JPG, JPEG, PNG, or BMP)', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;
                
                // Store image data
                if (imageType === 'producedFor') {
                    producedForImage = imageData;
                } else if (imageType === 'producedBy') {
                    producedByImage = imageData;
                }

                // Display image preview
                const previewDiv = document.getElementById(`${imageType}ImagePreview`);
                previewDiv.innerHTML = `<img src="${imageData}" alt="${imageType} logo">`;
                previewDiv.classList.add('has-image');

                // Show remove button
                document.getElementById(`remove${imageType.charAt(0).toUpperCase() + imageType.slice(1)}Image`).style.display = 'inline-block';

                showStatus('Image uploaded successfully! âœ“', 'success');
            };
            reader.readAsDataURL(file);
        }

        // Remove uploaded image
        function removeImage(imageType) {
            if (confirm('Are you sure you want to remove this logo?')) {
                // Clear image data
                if (imageType === 'producedFor') {
                    producedForImage = null;
                } else if (imageType === 'producedBy') {
                    producedByImage = null;
                }

                // Clear preview
                const previewDiv = document.getElementById(`${imageType}ImagePreview`);
                previewDiv.innerHTML = '<span style="color: #999; font-size: 0.9em;">No image</span>';
                previewDiv.classList.remove('has-image');

                // Hide remove button
                document.getElementById(`remove${imageType.charAt(0).toUpperCase() + imageType.slice(1)}Image`).style.display = 'none';

                // Clear file input
                document.getElementById(`${imageType}ImageInput`).value = '';

                showStatus('Image removed! âœ“', 'success');
            }
        }

        // Add custom section
        function addCustomSection() {
            customSectionCounter++;
            const sectionId = `customSection${customSectionCounter}`;
            const headingId = `${sectionId}Heading`;
            const inputId = `${sectionId}Input`;
            
            const container = document.getElementById('customSectionsContainer');
            
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'section-container';
            sectionDiv.id = sectionId;
            sectionDiv.innerHTML = `
                <div class="section-header-editable">
                    <h3 id="${headingId}" contenteditable="false">Custom Section ${customSectionCounter}</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-rename" onclick="toggleEditHeading('${headingId}')">âœï¸ Rename</button>
                        <button class="btn-clear-section" onclick="clearSection('${inputId}', '${headingId}', 'Custom Section ${customSectionCounter}')">ğŸ—‘ï¸ Clear</button>
                        <button class="btn-remove-section" onclick="removeCustomSection('${sectionId}')" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 8px 16px; font-size: 0.95em; border: none; border-radius: 8px; cursor: pointer;">
                            âŒ Remove
                        </button>
                    </div>
                </div>
                <textarea id="${inputId}" placeholder="Enter information for this custom section on separate lines"></textarea>
            `;
            
            container.appendChild(sectionDiv);
            showStatus('Custom section added! âœ“', 'success');
        }

        // Remove custom section
        function removeCustomSection(sectionId) {
            if (confirm('Are you sure you want to remove this section? This cannot be undone!')) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.remove();
                    showStatus('Section removed! âœ“', 'success');
                }
            }
        }

        // Tab functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
                
                // Remove active class from all tabs and contents
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                this.classList.add('active');
                document.getElementById(tabId).classList.add('active');
                
                // If duties tab is clicked and no duties exist, add one duty with one task
                if (tabId === 'duties-tab') {
                    const dutiesContainer = document.getElementById('dutiesContainer');
                    if (dutiesContainer.children.length === 0) {
                        addDuty();
                        const currentDutyId = `duty_${dutyCount}`;
                        addTask(currentDutyId);
                    }
                }
            });
        });

        // Initialize: Add one duty with one task on page load
        window.addEventListener('DOMContentLoaded', function() {
            addDuty();
            const currentDutyId = `duty_${dutyCount}`;
            addTask(currentDutyId);
        });

        // Duty management
        let dutyCount = 0;
        
        function addDuty() {
            dutyCount++;
            const dutyDiv = document.createElement('div');
            dutyDiv.className = 'duty-row';
            dutyDiv.id = `duty_${dutyCount}`;
            dutyDiv.innerHTML = `
                <div class="duty-header">
                    <h4>Duty ${dutyCount}</h4>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-clear-section" onclick="clearDuty('duty_${dutyCount}')">ğŸ—‘ï¸ Clear</button>
                        <button class="btn-remove" onclick="removeDuty('duty_${dutyCount}')">ğŸ—‘ï¸ Remove Duty</button>
                    </div>
                </div>
                <input type="text" placeholder="Enter duty description" data-duty-id="duty_${dutyCount}">
                <div class="task-list" id="tasks_duty_${dutyCount}"></div>
                <button class="btn-add" onclick="addTask('duty_${dutyCount}')">â• Add Task</button>
            `;
            document.getElementById('dutiesContainer').appendChild(dutyDiv);
        }
        
        function removeDuty(dutyId) {
            document.getElementById(dutyId).remove();
        }
        
        let taskCounts = {};
        
        function addTask(dutyId) {
            if (!taskCounts[dutyId]) taskCounts[dutyId] = 0;
            taskCounts[dutyId]++;
            
            const taskDiv = document.createElement('div');
            taskDiv.className = 'task-item';
            taskDiv.id = `task_${dutyId}_${taskCounts[dutyId]}`;
            taskDiv.innerHTML = `
                <span class="task-label">Task ${taskCounts[dutyId]}:</span>
                <input type="text" style="flex: 1;" placeholder="Enter task description" data-task-id="${dutyId}_${taskCounts[dutyId]}">
                <button class="btn-remove" onclick="removeTask('task_${dutyId}_${taskCounts[dutyId]}')">ğŸ—‘ï¸</button>
            `;
            document.getElementById(`tasks_${dutyId}`).appendChild(taskDiv);
        }
        
        function removeTask(taskId) {
            document.getElementById(taskId).remove();
        }

        // Toggle heading edit mode
        function toggleEditHeading(headingId) {
            const heading = document.getElementById(headingId);
            const isEditable = heading.getAttribute('contenteditable') === 'true';
            
            if (isEditable) {
                // Save and exit edit mode
                heading.setAttribute('contenteditable', 'false');
                heading.style.cursor = '';
                showStatus('Heading updated! âœ“', 'success');
            } else {
                // Enter edit mode
                heading.setAttribute('contenteditable', 'true');
                heading.focus();
                
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(heading);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }

        // Clear section in Additional Info tab
        function clearSection(inputId, headingId, defaultHeading) {
            if (confirm('Are you sure you want to clear this section?')) {
                document.getElementById(inputId).value = '';
                document.getElementById(headingId).textContent = defaultHeading;
                document.getElementById(headingId).setAttribute('contenteditable', 'false');
                showStatus('Section cleared! âœ“', 'success');
            }
        }

        // Format list with numbering or bullets
        function formatList(inputId, formatType) {
            const textarea = document.getElementById(inputId);
            const text = textarea.value.trim();
            
            if (!text) {
                showStatus('Nothing to format! Add some content first.', 'error');
                return;
            }
            
            // Split by lines and filter out empty lines
            let lines = text.split('\n').filter(line => line.trim());
            
            // Remove existing bullets or numbers from lines
            lines = lines.map(line => {
                // Remove leading bullets (â€¢, -, *, â—‹, â—, etc.)
                line = line.replace(/^[\s]*[â€¢\-\*â—‹â—]\s*/, '');
                // Remove leading numbers (1., 1), (1, etc.)
                line = line.replace(/^[\s]*\d+[\.\)]\s*/, '');
                return line.trim();
            });
            
            // Apply new formatting
            let formatted = [];
            if (formatType === 'number') {
                lines.forEach((line, index) => {
                    formatted.push(`${index + 1}. ${line}`);
                });
            } else if (formatType === 'bullet') {
                lines.forEach(line => {
                    formatted.push(`â€¢ ${line}`);
                });
            }
            
            // Update textarea
            textarea.value = formatted.join('\n');
            
            showStatus(`âœ“ Formatted with ${formatType === 'number' ? 'numbering' : 'bullets'}!`, 'success');
        }

        // Clear specific duty section
        function clearDuty(dutyId) {
            if (confirm('Are you sure you want to clear this duty and all its tasks?')) {
                // Clear duty input
                const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                if (dutyInput) {
                    dutyInput.value = '';
                }
                
                // Clear all tasks
                const taskInputs = document.querySelectorAll(`[data-task-id^="${dutyId}_"]`);
                taskInputs.forEach(taskInput => {
                    taskInput.value = '';
                });
                
                showStatus('Duty cleared! âœ“', 'success');
            }
        }

        // ============ TASK VERIFICATION & TRAINING PRIORITY FUNCTIONS ============
        
        // Store for verification ratings
        // Structure: { 
        //   dutyId_taskId: { 
        //     importance: 0-3, 
        //     frequency: 0-3, 
        //     difficulty: 0-3,
        //     performsTask: boolean (Extended mode),
        //     criticality: 0-3 (Extended mode),
        //     comments: string (optional)
        //   } 
        // }
        let verificationRatings = {};
        let taskMetadata = {}; // Stores dutyId and dutyTitle for each task
        let collectionMode = 'workshop'; // Default: workshop
        let workflowMode = 'standard'; // Default: standard
        
        // ============ WORKSHOP AGGREGATED COUNTS VARIABLES ============
        // Workshop-specific data
        let workshopParticipants = 10; // Default number of participants
        let priorityFormula = 'if'; // Default: Importance Ã— Frequency
        
        // Task Verification export mode ('appendix' or 'standalone')
        let tvExportMode = 'appendix'; // Default: include as appendix
        let trainingLoadMethod = 'advanced'; // Default: advanced method for training load
        
        // Workshop counts structure
        // Structure: {
        //   dutyId_taskId: {
        //     importanceCounts: {0: X, 1: Y, 2: Z, 3: W},
        //     frequencyCounts: {0: X, 1: Y, 2: Z, 3: W},
        //     difficultyCounts: {0: X, 1: Y, 2: Z, 3: W},
        //     criticalityCounts: {0: X, 1: Y, 2: Z, 3: W} (Extended only)
        //   }
        // }
        let workshopCounts = {};
        
        // Computed workshop results (weighted means and priority index)
        // Structure: {
        //   dutyId_taskId: {
        //     meanImportance: float,
        //     meanFrequency: float,
        //     meanDifficulty: float,
        //     meanCriticality: float (Extended only),
        //     priorityIndex: float,
        //     valid: boolean (sum validation passed)
        //   }
        // }
        let workshopResults = {};

        // Update collection mode
        function updateCollectionMode() {
            const workshopRadio = document.getElementById('mode-workshop');
            const surveyRadio = document.getElementById('mode-survey');
            
            if (workshopRadio.checked) {
                collectionMode = 'workshop';
            } else if (surveyRadio.checked) {
                collectionMode = 'survey';
            }
            
            // Show/hide workshop-specific fields
            const workshopSection = document.getElementById('workshopParticipantsSection');
            const dashboardSection = document.getElementById('resultsDashboard');
            
            if (collectionMode === 'workshop') {
                workshopSection.style.display = 'block';
                dashboardSection.style.display = 'block';
            } else {
                workshopSection.style.display = 'none';
                dashboardSection.style.display = 'none';
            }
            
            // Re-render verification UI to switch between count inputs and radio buttons
            loadDutiesForVerification();
            
            console.log('Collection mode updated to:', collectionMode);
            showStatus(`Data collection mode: ${collectionMode === 'workshop' ? 'Workshop (Facilitated)' : 'Individual / Survey'}`, 'success');
        }

        // Update workflow mode
        function updateWorkflowMode() {
            const standardRadio = document.getElementById('workflow-standard');
            const extendedRadio = document.getElementById('workflow-extended');
            
            if (standardRadio.checked) {
                workflowMode = 'standard';
            } else if (extendedRadio.checked) {
                workflowMode = 'extended';
            }
            
            console.log('Workflow mode updated to:', workflowMode);
            
            // Update UI to show/hide extended columns
            const container = document.getElementById('verificationAccordionContainer');
            if (workflowMode === 'extended') {
                container.classList.add('workflow-extended');
            } else {
                container.classList.remove('workflow-extended');
            }
            
            // Re-render the verification UI to show/hide extended fields
            // This preserves existing data
            loadDutiesForVerification();
            
            // Show/hide priority formula selector (Standard mode only)
            const priorityFormulaSection = document.getElementById('priorityFormulaSection');
            if (workflowMode === 'standard' && collectionMode === 'workshop') {
                priorityFormulaSection.style.display = 'block';
            } else {
                priorityFormulaSection.style.display = 'none';
            }
            
            showStatus(`Workflow mode: ${workflowMode === 'standard' ? 'Standard (DACUM)' : 'Extended (DACUM)'}`, 'success');
        }

        // Update workshop participant count
        function updateParticipantCount() {
            const input = document.getElementById('workshopParticipants');
            workshopParticipants = parseInt(input.value) || 10;
            console.log('Workshop participants updated to:', workshopParticipants);
            
            // Re-validate all tasks
            validateAndComputeWorkshopResults();
            showStatus(`Participants set to ${workshopParticipants}. Re-validating all tasks...`, 'success');
        }

        // Update priority formula
        function updatePriorityFormula() {
            const ifRadio = document.getElementById('formula-if');
            const ifdRadio = document.getElementById('formula-ifd');
            
            if (ifRadio.checked) {
                priorityFormula = 'if';
            } else if (ifdRadio.checked) {
                priorityFormula = 'ifd';
            }
            
            console.log('Priority formula updated to:', priorityFormula);
            
            // Recalculate priority indices
            validateAndComputeWorkshopResults();
            refreshDashboard();
            
            showStatus(`Priority formula: ${priorityFormula === 'if' ? 'I Ã— F' : 'I Ã— F Ã— D'}`, 'success');
        }

        // Update Task Verification export mode
        function updateTVExportMode() {
            const appendixRadio = document.getElementById('tvExportAppendix');
            const standaloneRadio = document.getElementById('tvExportStandalone');
            
            if (appendixRadio && appendixRadio.checked) {
                tvExportMode = 'appendix';
            } else if (standaloneRadio && standaloneRadio.checked) {
                tvExportMode = 'standalone';
            }
            
            console.log('Task Verification export mode:', tvExportMode);
            showStatus(`Export mode: ${tvExportMode === 'appendix' ? 'Include as Appendix' : 'Standalone Report'}`, 'success');
        }

        // Load duties and tasks from existing DACUM structure and create verification UI
        function loadDutiesForVerification() {
            const container = document.getElementById('verificationAccordionContainer');
            
            // Get all duties from the duties container
            const dutyInputs = document.querySelectorAll('[data-duty-id]');
            
            if (dutyInputs.length === 0) {
                container.innerHTML = `
                    <div class="no-duties-message">
                        <h3>âš ï¸ No Duties Found</h3>
                        <p>Please go to the "Duties & Tasks" tab and create duties with tasks first.</p>
                        <p style="margin-top: 10px;">Once you've added duties and tasks, click the "Refresh Duties & Tasks" button above.</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = ''; // Clear existing content
            
            let totalDuties = 0;
            let totalTasks = 0;
            
            // Iterate through each duty
            dutyInputs.forEach((dutyInput) => {
                const dutyId = dutyInput.getAttribute('data-duty-id');
                const dutyText = dutyInput.value.trim();
                
                if (!dutyText) return; // Skip empty duties
                
                totalDuties++;
                
                // Get all tasks for this duty
                const taskInputs = document.querySelectorAll(`[data-task-id^="${dutyId}_"]`);
                const tasks = [];
                
                taskInputs.forEach((taskInput) => {
                    const taskText = taskInput.value.trim();
                    if (taskText) {
                        const taskId = taskInput.getAttribute('data-task-id');
                        
                        // Store metadata for this task
                        taskMetadata[taskId] = {
                            dutyId: dutyId,
                            dutyTitle: dutyText,
                            taskTitle: taskText
                        };
                        
                        tasks.push({ 
                            id: taskId, 
                            text: taskText,
                            dutyId: dutyId,
                            dutyTitle: dutyText
                        });
                        totalTasks++;
                    }
                });
                
                if (tasks.length === 0) return; // Skip duties with no tasks
                
                // Create accordion for this duty
                const accordionHtml = createDutyAccordion(dutyId, dutyText, tasks);
                container.insertAdjacentHTML('beforeend', accordionHtml);
            });
            
            // Attach event listeners to accordion headers
            attachAccordionListeners();
            
            showStatus(`âœ“ Loaded ${totalDuties} duties with ${totalTasks} tasks for verification`, 'success');
        }

        // Create accordion HTML for a duty with its tasks
        // Create accordion HTML for a duty with its tasks
        // Supports both Standard and Extended workflow modes
        function createDutyAccordion(dutyId, dutyText, tasks) {
            const isExtended = workflowMode === 'extended';
            
            const tasksTableRows = tasks.map((task, index) => {
                const taskKey = task.id;
                const ratings = verificationRatings[taskKey] || { 
                    importance: null, 
                    frequency: null, 
                    difficulty: null,
                    performsTask: false,
                    criticality: null,
                    comments: ''
                };
                
                // Calculate completion status (Standard mode)
                const isComplete = ratings.importance !== null && 
                                   ratings.frequency !== null && 
                                   ratings.difficulty !== null;
                const completionHtml = `
                    <span class="completion-indicator ${isComplete ? 'complete' : 'incomplete'}">
                        ${isComplete ? 'âœ“ Complete' : 'â—‹ Incomplete'}
                    </span>
                `;
                
                // Calculate Task Score (Standard mode)
                const taskScore = isComplete ? 
                    (ratings.importance + ratings.frequency + ratings.difficulty) : 
                    '-';
                
                // Calculate Weighted Score and Priority (Extended mode)
                let weightedScore = '-';
                let priorityLevel = 'low';
                if (isExtended && ratings.importance !== null && ratings.frequency !== null && 
                    ratings.difficulty !== null && ratings.criticality !== null) {
                    weightedScore = (ratings.importance * ratings.frequency) + 
                                    ratings.difficulty + ratings.criticality;
                    
                    // Determine priority level
                    if (weightedScore >= 10) {
                        priorityLevel = 'high';
                    } else if (weightedScore >= 6) {
                        priorityLevel = 'medium';
                    } else {
                        priorityLevel = 'low';
                    }
                }
                
                const priorityHtml = `
                    <span class="priority-badge ${priorityLevel}">
                        ${priorityLevel.toUpperCase()}
                    </span>
                `;
                
                // Build row HTML - Support both Workshop (counts) and Survey (radio) modes
                const isWorkshop = collectionMode === 'workshop';
                
                // For Workshop mode in Standard workflow, show weighted means
                let workshopMeans = '';
                if (isWorkshop && !isExtended && workshopResults[taskKey] && workshopResults[taskKey].valid) {
                    const res = workshopResults[taskKey];
                    workshopMeans = `
                        <td style="width: 8%; text-align: center;">
                            <span class="weighted-mean" id="mean_imp_${taskKey}">${res.meanImportance.toFixed(2)}</span>
                        </td>
                        <td style="width: 8%; text-align: center;">
                            <span class="weighted-mean" id="mean_freq_${taskKey}">${res.meanFrequency.toFixed(2)}</span>
                        </td>
                        <td style="width: 8%; text-align: center;">
                            <span class="weighted-mean" id="mean_diff_${taskKey}">${res.meanDifficulty.toFixed(2)}</span>
                        </td>
                        <td style="width: 8%; text-align: center;">
                            <span class="priority-index" id="priority_${taskKey}">${res.priorityIndex.toFixed(2)}</span>
                        </td>
                    `;
                } else if (isWorkshop && !isExtended) {
                    workshopMeans = `
                        <td style="width: 8%; text-align: center;">
                            <span class="weighted-mean" id="mean_imp_${taskKey}">-</span>
                        </td>
                        <td style="width: 8%; text-align: center;">
                            <span class="weighted-mean" id="mean_freq_${taskKey}">-</span>
                        </td>
                        <td style="width: 8%; text-align: center;">
                            <span class="weighted-mean" id="mean_diff_${taskKey}">-</span>
                        </td>
                        <td style="width: 8%; text-align: center;">
                            <span class="priority-index" id="priority_${taskKey}">-</span>
                        </td>
                    `;
                }
                
                return `
                    <tr data-task-key="${taskKey}">
                        <td style="width: ${isExtended ? '25%' : (isWorkshop ? '28%' : '40%')};">
                            <div class="task-text">${index + 1}. ${escapeHtml(task.text)}</div>
                        </td>
                        <td style="width: ${isExtended ? '12%' : '15%'};">
                            ${isWorkshop ? createCountInputs(taskKey, 'importance') : createRatingScale(taskKey, 'importance', ratings.importance)}
                        </td>
                        <td style="width: ${isExtended ? '12%' : '15%'};">
                            ${isWorkshop ? createCountInputs(taskKey, 'frequency') : createRatingScale(taskKey, 'frequency', ratings.frequency)}
                        </td>
                        <td style="width: ${isExtended ? '12%' : '15%'};">
                            ${isWorkshop ? createCountInputs(taskKey, 'difficulty') : createRatingScale(taskKey, 'difficulty', ratings.difficulty)}
                        </td>
                        ${!isExtended && !isWorkshop ? `
                            <td style="width: 8%; text-align: center;">
                                <span class="score-display" id="score_${taskKey}">${taskScore}</span>
                            </td>
                            <td style="width: 12%; text-align: center;">
                                <span id="completion_${taskKey}">${completionHtml}</span>
                            </td>
                        ` : ''}
                        ${!isExtended && isWorkshop ? workshopMeans : ''}
                        ${isExtended ? `
                            <td class="extended-only" style="width: 10%; text-align: center;">
                                <div class="performs-task-toggle">
                                    <input type="checkbox" 
                                           id="performs_${taskKey}"
                                           ${ratings.performsTask ? 'checked' : ''}
                                           onchange="updatePerformsTask('${taskKey}', this.checked)">
                                    <label for="performs_${taskKey}">Yes</label>
                                </div>
                            </td>
                            <td class="extended-only" style="width: 12%;">
                                ${isWorkshop ? createCountInputs(taskKey, 'criticality') : createRatingScale(taskKey, 'criticality', ratings.criticality)}
                            </td>
                            <td class="extended-only" style="width: 8%; text-align: center;">
                                <span class="score-display" id="weighted_${taskKey}">${weightedScore}</span>
                            </td>
                            <td class="extended-only" style="width: 10%; text-align: center;">
                                <span id="priority_${taskKey}">${priorityHtml}</span>
                            </td>
                            <td class="extended-only" style="width: 15%;">
                                <textarea class="task-comments" 
                                          id="comments_${taskKey}"
                                          placeholder="Optional comments..."
                                          onchange="updateComments('${taskKey}', this.value)">${escapeHtml(ratings.comments || '')}</textarea>
                            </td>
                        ` : ''}
                    </tr>
                `;
            }).join('');
            
            // Build table header based on mode and collection mode
            const isWorkshop = collectionMode === 'workshop';
            const tableHeader = !isExtended && !isWorkshop ? `
                <tr>
                    <th>Task</th>
                    <th>Importance<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th>Frequency<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th>Learning Difficulty<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th>Task Score</th>
                    <th>Completion</th>
                </tr>
            ` : !isExtended && isWorkshop ? `
                <tr>
                    <th>Task</th>
                    <th>Importance Counts<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th>Frequency Counts<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th>Difficulty Counts<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th>Mean<br>Importance</th>
                    <th>Mean<br>Frequency</th>
                    <th>Mean<br>Difficulty</th>
                    <th>Priority<br>Index</th>
                </tr>
            ` : `
                <tr>
                    <th>Task</th>
                    <th>${isWorkshop ? 'Importance Counts' : 'Importance'}<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th>${isWorkshop ? 'Frequency Counts' : 'Frequency'}<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th>${isWorkshop ? 'Difficulty Counts' : 'Difficulty'}<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th class="extended-only">Performs?</th>
                    <th class="extended-only">${isWorkshop ? 'Criticality Counts' : 'Criticality'}<br><span style="font-weight: 400; font-size: 0.85em;">(0-3)</span></th>
                    <th class="extended-only">Weighted Score</th>
                    <th class="extended-only">Priority</th>
                    <th class="extended-only">Comments</th>
                </tr>
            `;
            
            return `
                <div class="duty-accordion">
                    <div class="duty-accordion-header" data-duty="${dutyId}">
                        <div class="duty-title">${escapeHtml(dutyText)}</div>
                        <div class="duty-toggle">â–¼</div>
                    </div>
                    <div class="duty-accordion-content">
                        <div style="overflow-x: auto; width: 100%;">
                            <table class="verification-table">
                                <thead>
                                    ${tableHeader}
                                </thead>
                                <tbody>
                                    ${tasksTableRows}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        // Create rating scale HTML for a specific dimension
        function createRatingScale(taskKey, dimension, currentValue) {
            const scales = [0, 1, 2, 3];
            
            return `
                <div class="rating-scale">
                    ${scales.map(value => {
                        const isChecked = currentValue === value ? 'checked' : '';
                        const inputId = `${taskKey}_${dimension}_${value}`;
                        return `
                            <div class="rating-option">
                                <input type="radio" 
                                       id="${inputId}"
                                       name="${taskKey}_${dimension}" 
                                       value="${value}" 
                                       ${isChecked}
                                       onchange="updateRating('${taskKey}', '${dimension}', ${value})">
                                <label for="${inputId}">${value}</label>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ============ WORKSHOP COUNT INPUTS FUNCTION ============
        // Create count inputs for Workshop mode (aggregated counts)
        // Used instead of radio buttons when collectionMode = 'workshop'
        function createCountInputs(taskKey, dimension) {
            const scales = [0, 1, 2, 3];
            
            // Get existing counts if any
            const counts = workshopCounts[taskKey] || {};
            const dimensionCounts = counts[`${dimension}Counts`] || {0: 0, 1: 0, 2: 0, 3: 0};
            
            return `
                <div class="count-input-grid">
                    ${scales.map(value => {
                        const inputId = `${taskKey}_${dimension}_count_${value}`;
                        const currentCount = dimensionCounts[value] || 0;
                        return `
                            <div class="count-input-item">
                                <label for="${inputId}">${value}</label>
                                <input type="number" 
                                       id="${inputId}"
                                       min="0" 
                                       max="${workshopParticipants}"
                                       value="${currentCount}"
                                       onchange="updateWorkshopCount('${taskKey}', '${dimension}', ${value}, this.value)"
                                       oninput="this.value = Math.max(0, Math.min(${workshopParticipants}, parseInt(this.value) || 0))">
                            </div>
                        `;
                    }).join('')}
                </div>
                <div class="validation-warning" id="warning_${taskKey}_${dimension}">
                    <!-- Validation message will be inserted here dynamically -->
                </div>
            `;
        }

        // Update rating when user selects a radio button
        // Update rating when user selects a radio button
        // Includes live computation updates for scores and completion
        function updateRating(taskKey, dimension, value) {
            // Initialize task ratings if not exists
            if (!verificationRatings[taskKey]) {
                // Get duty information from taskMetadata
                let dutyId, dutyTitle, taskTitle;
                if (taskMetadata[taskKey]) {
                    dutyId = taskMetadata[taskKey].dutyId;
                    dutyTitle = taskMetadata[taskKey].dutyTitle;
                    taskTitle = taskMetadata[taskKey].taskTitle;
                }
                
                verificationRatings[taskKey] = {
                    dutyId: dutyId,
                    dutyTitle: dutyTitle,
                    taskTitle: taskTitle,
                    importance: null,
                    frequency: null,
                    difficulty: null,
                    performsTask: false,
                    criticality: null,
                    comments: ''
                };
            }
            
            // Update the specific dimension
            verificationRatings[taskKey][dimension] = parseInt(value);
            
            console.log('Rating updated:', taskKey, dimension, value);
            console.log('Current ratings:', verificationRatings);
            
            // Live update computed values
            updateComputedValues(taskKey);
            
            // NOTE: Future enhancement - Calculate average and priority across multiple raters
            // TODO: Add logic to compute:
            // - Average importance across all raters
            // - Average frequency across all raters
            // - Average difficulty across all raters
            // - Training priority score aggregation
            // - Sort tasks by priority
        }

        // Update "Performs Task" checkbox (Extended mode only)
        function updatePerformsTask(taskKey, value) {
            if (!verificationRatings[taskKey]) {
                // Get duty information from taskMetadata
                let dutyId, dutyTitle, taskTitle;
                if (taskMetadata[taskKey]) {
                    dutyId = taskMetadata[taskKey].dutyId;
                    dutyTitle = taskMetadata[taskKey].dutyTitle;
                    taskTitle = taskMetadata[taskKey].taskTitle;
                }
                
                verificationRatings[taskKey] = {
                    dutyId: dutyId,
                    dutyTitle: dutyTitle,
                    taskTitle: taskTitle,
                    importance: null,
                    frequency: null,
                    difficulty: null,
                    performsTask: false,
                    criticality: null,
                    comments: ''
                };
            }
            
            verificationRatings[taskKey].performsTask = value;
            console.log('Performs task updated:', taskKey, value);
        }

        // Update comments (Extended mode only)
        function updateComments(taskKey, value) {
            if (!verificationRatings[taskKey]) {
                // Get duty information from taskMetadata
                let dutyId, dutyTitle, taskTitle;
                if (taskMetadata[taskKey]) {
                    dutyId = taskMetadata[taskKey].dutyId;
                    dutyTitle = taskMetadata[taskKey].dutyTitle;
                    taskTitle = taskMetadata[taskKey].taskTitle;
                }
                
                verificationRatings[taskKey] = {
                    dutyId: dutyId,
                    dutyTitle: dutyTitle,
                    taskTitle: taskTitle,
                    importance: null,
                    frequency: null,
                    difficulty: null,
                    performsTask: false,
                    criticality: null,
                    comments: ''
                };
            }
            
            verificationRatings[taskKey].comments = value;
            console.log('Comments updated:', taskKey, value);
        }

        // Live computation of scores, completion, and priority
        function updateComputedValues(taskKey) {
            const ratings = verificationRatings[taskKey];
            if (!ratings) return;
            
            const isExtended = workflowMode === 'extended';
            
            if (!isExtended) {
                // Standard Mode: Update Task Score and Completion
                const scoreElement = document.getElementById(`score_${taskKey}`);
                const completionElement = document.getElementById(`completion_${taskKey}`);
                
                if (scoreElement && completionElement) {
                    const isComplete = ratings.importance !== null && 
                                       ratings.frequency !== null && 
                                       ratings.difficulty !== null;
                    
                    // Update score
                    const taskScore = isComplete ? 
                        (ratings.importance + ratings.frequency + ratings.difficulty) : 
                        '-';
                    scoreElement.textContent = taskScore;
                    
                    // Update completion
                    const completionHtml = `
                        <span class="completion-indicator ${isComplete ? 'complete' : 'incomplete'}">
                            ${isComplete ? 'âœ“ Complete' : 'â—‹ Incomplete'}
                        </span>
                    `;
                    completionElement.innerHTML = completionHtml;
                }
            } else {
                // Extended Mode: Update Weighted Score and Priority Level
                const weightedElement = document.getElementById(`weighted_${taskKey}`);
                const priorityElement = document.getElementById(`priority_${taskKey}`);
                
                if (weightedElement && priorityElement) {
                    if (ratings.importance !== null && ratings.frequency !== null && 
                        ratings.difficulty !== null && ratings.criticality !== null) {
                        
                        // Calculate weighted score
                        const weightedScore = (ratings.importance * ratings.frequency) + 
                                              ratings.difficulty + ratings.criticality;
                        weightedElement.textContent = weightedScore;
                        
                        // Determine priority level
                        let priorityLevel = 'low';
                        if (weightedScore >= 10) {
                            priorityLevel = 'high';
                        } else if (weightedScore >= 6) {
                            priorityLevel = 'medium';
                        }
                        
                        // Update priority
                        const priorityHtml = `
                            <span class="priority-badge ${priorityLevel}">
                                ${priorityLevel.toUpperCase()}
                            </span>
                        `;
                        priorityElement.innerHTML = priorityHtml;
                    } else {
                        weightedElement.textContent = '-';
                        priorityElement.innerHTML = `
                            <span class="priority-badge low">
                                LOW
                            </span>
                        `;
                    }
                }
            }
        }

        // ============ WORKSHOP AGGREGATED COUNTS FUNCTIONS ============
        
        // Update workshop count for a specific value
        function updateWorkshopCount(taskKey, dimension, value, count) {
            // Initialize workshopCounts structure if needed
            if (!workshopCounts[taskKey]) {
                // Get duty information from taskMetadata (preferred) or DOM (fallback)
                let dutyId, dutyTitle, taskTitle;
                
                if (taskMetadata[taskKey]) {
                    dutyId = taskMetadata[taskKey].dutyId;
                    dutyTitle = taskMetadata[taskKey].dutyTitle;
                    taskTitle = taskMetadata[taskKey].taskTitle;
                } else {
                    // Fallback to DOM lookup
                    const taskParts = taskKey.split('_task_');
                    dutyId = taskParts[0];
                    const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                    dutyTitle = dutyInput ? dutyInput.value.trim() : '';
                    const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                    taskTitle = taskInput ? taskInput.value.trim() : '';
                }
                
                workshopCounts[taskKey] = {
                    dutyId: dutyId,
                    dutyTitle: dutyTitle,
                    taskTitle: taskTitle,
                    importanceCounts: {0: 0, 1: 0, 2: 0, 3: 0},
                    frequencyCounts: {0: 0, 1: 0, 2: 0, 3: 0},
                    difficultyCounts: {0: 0, 1: 0, 2: 0, 3: 0},
                    criticalityCounts: {0: 0, 1: 0, 2: 0, 3: 0}
                };
            }
            
            // Update the count
            const dimensionKey = `${dimension}Counts`;
            workshopCounts[taskKey][dimensionKey][value] = parseInt(count) || 0;
            
            console.log('Workshop count updated:', taskKey, dimension, value, count);
            
            // Validate and compute for this task
            validateAndComputeTask(taskKey);
        }
        
        // Validate a single task's counts and compute weighted means
        // ============ VALIDATION AND COMPUTATION (DACUM Methodology) ============
        // Validate counts and compute weighted means for a task
        //
        // VALIDATION LOGIC (Corrected for DACUM best practices):
        //   âŒ ERROR (blocking): sum > totalParticipants
        //      - More responses than participants (impossible/error)
        //      - Do NOT calculate, mark as invalid
        //
        //   âš ï¸ WARNING (non-blocking): sum < totalParticipants  
        //      - Partial responses (some participants didn't respond)
        //      - This is ALLOWED in DACUM methodology
        //      - STILL calculate using available responses
        //
        //   âœ… OK: sum === totalParticipants
        //      - All participants responded
        //      - Calculate normally
        //
        //   âœ… OK: sum === 0
        //      - No responses yet
        //      - Don't calculate (display "N/A")
        function validateAndComputeTask(taskKey) {
            if (!workshopCounts[taskKey]) return;
            
            const counts = workshopCounts[taskKey];
            const isExtended = workflowMode === 'extended';
            
            // Calculate sum for each dimension
            const importanceSum = Object.values(counts.importanceCounts).reduce((a, b) => a + b, 0);
            const frequencySum = Object.values(counts.frequencyCounts).reduce((a, b) => a + b, 0);
            const difficultySum = Object.values(counts.difficultyCounts).reduce((a, b) => a + b, 0);
            
            // Validate each dimension:
            // - Error if sum > participants (blocking)
            // - Warning if sum < participants (non-blocking)
            // - OK if sum === participants or sum === 0
            const importanceError = importanceSum > workshopParticipants;
            const frequencyError = frequencySum > workshopParticipants;
            const difficultyError = difficultySum > workshopParticipants;
            
            const importanceWarning = importanceSum < workshopParticipants && importanceSum > 0;
            const frequencyWarning = frequencySum < workshopParticipants && frequencySum > 0;
            const difficultyWarning = difficultySum < workshopParticipants && difficultySum > 0;
            
            let criticalityError = false;
            let criticalityWarning = false;
            let criticalitySum = 0;
            
            if (isExtended) {
                criticalitySum = Object.values(counts.criticalityCounts).reduce((a, b) => a + b, 0);
                criticalityError = criticalitySum > workshopParticipants;
                criticalityWarning = criticalitySum < workshopParticipants && criticalitySum > 0;
            }
            
            // Show validation messages (error takes precedence over warning)
            showValidationMessage(taskKey, 'importance', importanceError, importanceWarning, importanceSum);
            showValidationMessage(taskKey, 'frequency', frequencyError, frequencyWarning, frequencySum);
            showValidationMessage(taskKey, 'difficulty', difficultyError, difficultyWarning, difficultySum);
            if (isExtended) {
                showValidationMessage(taskKey, 'criticality', criticalityError, criticalityWarning, criticalitySum);
            }
            
            // Check if any dimension has errors (sum > participants)
            const hasErrors = importanceError || frequencyError || difficultyError || 
                             (isExtended ? criticalityError : false);
            
            // Calculate weighted means if no errors (warnings are OK!)
            // Also require at least one response per dimension
            const canCalculate = !hasErrors && 
                               importanceSum > 0 && 
                               frequencySum > 0 && 
                               difficultySum > 0 &&
                               (isExtended ? criticalitySum > 0 : true);
            
            if (canCalculate) {
                // Calculate weighted means using ACTUAL response counts
                // Returns null if no responses
                const meanImportance = calculateWeightedMean(counts.importanceCounts);
                const meanFrequency = calculateWeightedMean(counts.frequencyCounts);
                const meanDifficulty = calculateWeightedMean(counts.difficultyCounts);
                const meanCriticality = isExtended ? calculateWeightedMean(counts.criticalityCounts) : null;
                
                // Only proceed if we got valid means (not null)
                if (meanImportance !== null && meanFrequency !== null && meanDifficulty !== null &&
                    (isExtended ? meanCriticality !== null : true)) {
                    
                    // Calculate Priority Index based on selected formula
                    let priorityIndex = 0;
                    if (priorityFormula === 'if') {
                        // Importance Ã— Frequency
                        priorityIndex = meanImportance * meanFrequency;
                    } else {
                        // Importance Ã— Frequency Ã— Difficulty
                        priorityIndex = meanImportance * meanFrequency * meanDifficulty;
                    }
                    
                    // Use stored duty and task titles from workshopCounts (with fallback to DOM)
                    let dutyTitle = counts.dutyTitle;
                    let taskTitle = counts.taskTitle;
                    
                    // Fallback to DOM lookup if not stored (backward compatibility)
                    if (!dutyTitle || !taskTitle) {
                        const taskParts = taskKey.split('_task_');
                        const dutyId = taskParts[0];
                        
                        if (!dutyTitle) {
                            const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                            dutyTitle = dutyInput ? dutyInput.value.trim() : '';
                        }
                        
                        if (!taskTitle) {
                            const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                            taskTitle = taskInput ? taskInput.value.trim() : '';
                        }
                    }
                    
                    // Store results with duty and task titles
                    workshopResults[taskKey] = {
                        dutyTitle: dutyTitle,
                        taskTitle: taskTitle,
                        meanImportance: meanImportance,
                        meanFrequency: meanFrequency,
                        meanDifficulty: meanDifficulty,
                        meanCriticality: meanCriticality || 0,
                        priorityIndex: priorityIndex,
                        valid: true,
                        // Store response counts for transparency
                        responseCount: {
                            importance: importanceSum,
                            frequency: frequencySum,
                            difficulty: difficultySum,
                            criticality: criticalitySum
                        }
                    };
                    
                    console.log('Task computed (partial responses OK):', taskKey, workshopResults[taskKey]);
                    
                    // Update display if in Standard mode
                    if (workflowMode === 'standard') {
                        updateWorkshopTaskDisplay(taskKey);
                    }
                    
                    // Refresh dashboard
                    refreshDashboard();
                } else {
                    // Null means returned - no responses
                    if (workshopResults[taskKey]) {
                        workshopResults[taskKey].valid = false;
                    }
                }
            } else {
                // Errors present or no responses - mark as invalid
                if (workshopResults[taskKey]) {
                    workshopResults[taskKey].valid = false;
                }
            }
        }
        
        // Calculate weighted mean from counts
        // Formula: Î£(count Ã— value) Ã· total participants
        // ============ WEIGHTED MEAN CALCULATION (DACUM Methodology) ============
        // Calculate weighted mean from counts using ACTUAL responses, not total participants
        // This follows DACUM Handbook methodology for partial responses
        //
        // Formula: Weighted Mean = Î£(value Ã— count) Ã· totalResponses
        // 
        // Where:
        //   - value = scale value (0, 1, 2, or 3)
        //   - count = number of participants who selected this value
        //   - totalResponses = sum of all counts for this dimension
        //
        // Example:
        //   Counts: {0: 2, 1: 3, 2: 4, 3: 1}
        //   totalResponses = 2+3+4+1 = 10
        //   Weighted Mean = (0Ã—2 + 1Ã—3 + 2Ã—4 + 3Ã—1) Ã· 10
        //                 = (0 + 3 + 8 + 3) Ã· 10
        //                 = 14 Ã· 10 = 1.40
        //
        // CRITICAL: We use totalResponses (actual count sum), NOT totalParticipants
        // This allows for partial responses where not all participants respond to every scale
        function calculateWeightedMean(counts) {
            // Calculate weighted sum
            let weightedSum = 0;
            let totalResponses = 0;
            
            for (let value = 0; value <= 3; value++) {
                const count = counts[value] || 0;
                weightedSum += count * value;
                totalResponses += count;
            }
            
            // Return weighted mean, or null if no responses
            // Division by zero protection: if no responses, return null (not 0)
            return totalResponses > 0 ? (weightedSum / totalResponses) : null;
        }
        
        // Show/hide validation warning for a dimension
        // Show validation message (error or warning)
        // Error: sum > participants (blocking - red, severe)
        // Warning: sum < participants (non-blocking - yellow, informational)
        // OK: no message
        function showValidationMessage(taskKey, dimension, isError, isWarning, currentSum) {
            const warningEl = document.getElementById(`warning_${taskKey}_${dimension}`);
            if (!warningEl) return;
            
            if (isError) {
                // Error: Too many responses (blocking)
                warningEl.innerHTML = `<p>âŒ ERROR: Total responses (${currentSum}) exceeds ${workshopParticipants} participants. Cannot calculate.</p>`;
                warningEl.classList.add('show');
                warningEl.classList.add('error');
                warningEl.classList.remove('warning');
            } else if (isWarning) {
                // Warning: Partial responses (non-blocking)
                warningEl.innerHTML = `<p>âš ï¸ WARNING: Only ${currentSum} of ${workshopParticipants} participants responded. Calculation will use available responses.</p>`;
                warningEl.classList.add('show');
                warningEl.classList.add('warning');
                warningEl.classList.remove('error');
            } else {
                // OK: Hide message
                warningEl.classList.remove('show');
                warningEl.classList.remove('error');
                warningEl.classList.remove('warning');
            }
        }
        
        // Update workshop task display with weighted means
        // Update workshop task display with weighted means
        // Shows computed values or "N/A" if no valid data
        function updateWorkshopTaskDisplay(taskKey) {
            const result = workshopResults[taskKey];
            
            // Get display elements
            const meanImpEl = document.getElementById(`mean_imp_${taskKey}`);
            const meanFreqEl = document.getElementById(`mean_freq_${taskKey}`);
            const meanDiffEl = document.getElementById(`mean_diff_${taskKey}`);
            const priorityEl = document.getElementById(`priority_${taskKey}`);
            
            if (result && result.valid) {
                // Valid results - display computed values
                if (meanImpEl) meanImpEl.textContent = result.meanImportance !== null ? result.meanImportance.toFixed(2) : 'N/A';
                if (meanFreqEl) meanFreqEl.textContent = result.meanFrequency !== null ? result.meanFrequency.toFixed(2) : 'N/A';
                if (meanDiffEl) meanDiffEl.textContent = result.meanDifficulty !== null ? result.meanDifficulty.toFixed(2) : 'N/A';
                if (priorityEl) priorityEl.textContent = result.priorityIndex !== null ? result.priorityIndex.toFixed(2) : 'N/A';
            } else {
                // No valid results - display N/A or dash
                if (meanImpEl) meanImpEl.textContent = '-';
                if (meanFreqEl) meanFreqEl.textContent = '-';
                if (meanDiffEl) meanDiffEl.textContent = '-';
                if (priorityEl) priorityEl.textContent = '-';
            }
        }
        
        // Validate and compute all workshop results
        function validateAndComputeWorkshopResults() {
            if (collectionMode !== 'workshop') return;
            
            // Process all tasks that have counts
            Object.keys(workshopCounts).forEach(taskKey => {
                validateAndComputeTask(taskKey);
            });
            
            console.log('All workshop results validated and computed');
        }
        
        // ============ DASHBOARD FUNCTIONS ============
        
        // Toggle dashboard visibility
        function toggleDashboard() {
            const header = document.querySelector('.results-dashboard-header');
            const content = document.getElementById('dashboardContent');
            
            header.classList.toggle('active');
            content.classList.toggle('active');
        }
        
        // Refresh the dashboard with latest results
        function refreshDashboard() {
            if (collectionMode !== 'workshop') return;
            
            // Get all valid results
            const validResults = [];
            
            Object.keys(workshopResults).forEach(taskKey => {
                const result = workshopResults[taskKey];
                if (result && result.valid) {
                    // Use stored duty and task titles (with backward compatibility)
                    let dutyText = result.dutyTitle;
                    let taskText = result.taskTitle;
                    
                    // Backward compatibility: if not stored, look up from DOM
                    if (!dutyText || !taskText) {
                        const taskParts = taskKey.split('_task_');
                        const dutyId = taskParts[0];
                        
                        if (!dutyText) {
                            const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                            dutyText = dutyInput ? dutyInput.value.trim() : 'Unassigned Duty';
                        }
                        
                        if (!taskText) {
                            const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                            taskText = taskInput ? taskInput.value.trim() : 'Unassigned Task';
                        }
                    }
                    
                    validResults.push({
                        taskKey: taskKey,
                        duty: dutyText,
                        task: taskText,
                        meanImportance: result.meanImportance,
                        meanFrequency: result.meanFrequency,
                        meanDifficulty: result.meanDifficulty,
                        priorityIndex: result.priorityIndex
                    });
                }
            });
            
            // Sort by priority index (descending)
            validResults.sort((a, b) => b.priorityIndex - a.priorityIndex);
            
            // Update summary statistics
            updateDashboardSummary(validResults);
            
            // Update table
            updateDashboardTable(validResults);
            
            // Update duty-level summary
            updateDutyLevelSummary();
        }
        
        // Update dashboard summary cards
        function updateDashboardSummary(results) {
            const summaryContainer = document.getElementById('dashboardSummary');
            if (!summaryContainer) return;
            
            const totalTasks = results.length;
            const avgPriority = totalTasks > 0 ? 
                (results.reduce((sum, r) => sum + r.priorityIndex, 0) / totalTasks) : 0;
            const highPriorityCount = results.filter(r => {
                // High priority threshold (top 30%)
                const threshold = results[Math.floor(results.length * 0.3)]?.priorityIndex || 0;
                return r.priorityIndex >= threshold;
            }).length;
            
            summaryContainer.innerHTML = `
                <div class="summary-card">
                    <h4>Total Tasks</h4>
                    <p>${totalTasks}</p>
                </div>
                <div class="summary-card">
                    <h4>Average Priority</h4>
                    <p>${avgPriority.toFixed(2)}</p>
                </div>
                <div class="summary-card">
                    <h4>High Priority</h4>
                    <p>${highPriorityCount} tasks</p>
                </div>
                <div class="summary-card">
                    <h4>Formula Used</h4>
                    <p>${priorityFormula === 'if' ? 'I Ã— F' : 'I Ã— F Ã— D'}</p>
                </div>
            `;
        }
        
        // Update dashboard table with results
        function updateDashboardTable(results) {
            const tableBody = document.getElementById('dashboardTableBody');
            if (!tableBody) return;
            
            if (results.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="7" style="text-align: center; padding: 40px; color: #999;">
                            No valid task data available. Complete workshop counts to see results.
                        </td>
                    </tr>
                `;
                return;
            }
            
            // Determine top 30% threshold
            const topThreshold = results[Math.floor(results.length * 0.3)]?.priorityIndex || 0;
            
            const rows = results.map((r, index) => {
                const rank = index + 1;
                const isTop = r.priorityIndex >= topThreshold && rank <= Math.ceil(results.length * 0.3);
                const rowClass = isTop ? 'high-priority' : '';
                const rankBadge = isTop ? 'top' : '';
                
                return `
                    <tr class="${rowClass}">
                        <td><span class="rank-badge ${rankBadge}">#${rank}</span></td>
                        <td>${escapeHtml(r.duty)}</td>
                        <td>${escapeHtml(r.task)}</td>
                        <td><span class="mean-value">${r.meanImportance.toFixed(2)}</span></td>
                        <td><span class="mean-value">${r.meanFrequency.toFixed(2)}</span></td>
                        <td><span class="mean-value">${r.meanDifficulty.toFixed(2)}</span></td>
                        <td><span class="priority-index">${r.priorityIndex.toFixed(2)}</span></td>
                    </tr>
                `;
            }).join('');
            
            tableBody.innerHTML = rows;
        }
        
        // Toggle duty-level summary section
        function toggleDutyLevelSummary() {
            const content = document.getElementById('dutyLevelContent');
            const toggle = document.getElementById('dutyLevelToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = 'â–¼';
            } else {
                content.style.display = 'none';
                toggle.textContent = 'â–¶';
            }
        }
        
        // Update training load method
        function updateTrainingLoadMethod() {
            const advanced = document.querySelector('input[name="trainingLoadMethod"][value="advanced"]');
            trainingLoadMethod = advanced.checked ? 'advanced' : 'simple';
            
            // Update label
            const label = document.getElementById('trainingLoadMethodLabel');
            if (label) {
                label.innerHTML = `Current Method: <strong style="color: #667eea;">${trainingLoadMethod === 'advanced' ? 'Advanced' : 'Simple'}</strong>`;
            }
            
            // Recalculate duty-level summary
            updateDutyLevelSummary();
        }
        
        // Calculate and update duty-level summary
        function updateDutyLevelSummary() {
            if (collectionMode !== 'workshop') return;
            
            const tableBody = document.getElementById('dutyLevelTableBody');
            if (!tableBody) return;
            
            // Aggregate tasks by duty
            const dutyMap = {};
            
            Object.keys(workshopResults).forEach(taskKey => {
                const result = workshopResults[taskKey];
                if (result && result.valid) {
                    // Get duty information
                    let dutyId = result.dutyId || taskKey.split('_task_')[0];
                    let dutyTitle = result.dutyTitle;
                    
                    // Backward compatibility
                    if (!dutyTitle) {
                        const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                        dutyTitle = dutyInput ? dutyInput.value.trim() : 'Unassigned Duty';
                    }
                    
                    // Initialize duty entry if not exists
                    if (!dutyMap[dutyId]) {
                        dutyMap[dutyId] = {
                            dutyTitle: dutyTitle,
                            totalTasks: 0,
                            validTasks: 0,
                            importanceSum: 0,
                            frequencySum: 0,
                            difficultySum: 0,
                            prioritySum: 0,
                            highPriorityCount: 0,
                            tasks: []
                        };
                    }
                    
                    // Aggregate data
                    dutyMap[dutyId].totalTasks++;
                    dutyMap[dutyId].validTasks++;
                    dutyMap[dutyId].importanceSum += result.meanImportance;
                    dutyMap[dutyId].frequencySum += result.meanFrequency;
                    dutyMap[dutyId].difficultySum += result.meanDifficulty;
                    dutyMap[dutyId].prioritySum += result.priorityIndex;
                    
                    // Store task for training load calculation
                    dutyMap[dutyId].tasks.push({
                        priorityIndex: result.priorityIndex,
                        meanDifficulty: result.meanDifficulty
                    });
                }
            });
            
            // Calculate averages and training load for each duty
            const dutyResults = [];
            Object.keys(dutyMap).forEach(dutyId => {
                const duty = dutyMap[dutyId];
                const validCount = duty.validTasks;
                
                if (validCount > 0) {
                    const avgImportance = duty.importanceSum / validCount;
                    const avgFrequency = duty.frequencySum / validCount;
                    const avgDifficulty = duty.difficultySum / validCount;
                    const avgPriority = duty.prioritySum / validCount;
                    
                    // Calculate training load based on selected method
                    let trainingLoad = 0;
                    if (trainingLoadMethod === 'advanced') {
                        // Advanced: Î£ (Priority Index Ã— Mean Difficulty)
                        trainingLoad = duty.tasks.reduce((sum, task) => {
                            return sum + (task.priorityIndex * task.meanDifficulty);
                        }, 0);
                    } else {
                        // Simple: Average Priority Ã— Tasks Count
                        trainingLoad = avgPriority * validCount;
                    }
                    
                    // Count high priority tasks (top 30% based on priority index)
                    const sortedTasks = duty.tasks.sort((a, b) => b.priorityIndex - a.priorityIndex);
                    const threshold = sortedTasks[Math.floor(sortedTasks.length * 0.3)]?.priorityIndex || 0;
                    const highPriorityCount = sortedTasks.filter(t => t.priorityIndex >= threshold).length;
                    
                    dutyResults.push({
                        dutyTitle: duty.dutyTitle,
                        totalTasks: duty.totalTasks,
                        validTasks: validCount,
                        avgImportance: avgImportance,
                        avgFrequency: avgFrequency,
                        avgDifficulty: avgDifficulty,
                        avgPriority: avgPriority,
                        highPriorityCount: highPriorityCount,
                        trainingLoad: trainingLoad
                    });
                }
            });
            
            // Sort based on selected option
            const sortBy = document.getElementById('dutySortSelector')?.value || 'priority';
            if (sortBy === 'trainingLoad') {
                dutyResults.sort((a, b) => b.trainingLoad - a.trainingLoad);
            } else {
                dutyResults.sort((a, b) => b.avgPriority - a.avgPriority);
            }
            
            // Generate table rows
            if (dutyResults.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="9" style="text-align: center; padding: 40px; color: #999;">
                            No valid duty data available. Complete workshop counts to see results.
                        </td>
                    </tr>
                `;
                return;
            }
            
            const rows = dutyResults.map((duty, index) => {
                return `
                    <tr>
                        <td><strong>${escapeHtml(duty.dutyTitle)}</strong></td>
                        <td style="text-align: center;">${duty.totalTasks}</td>
                        <td style="text-align: center;">${duty.validTasks}</td>
                        <td style="text-align: center;"><span class="mean-value">${duty.avgImportance.toFixed(2)}</span></td>
                        <td style="text-align: center;"><span class="mean-value">${duty.avgFrequency.toFixed(2)}</span></td>
                        <td style="text-align: center;"><span class="mean-value">${duty.avgDifficulty.toFixed(2)}</span></td>
                        <td style="text-align: center;"><span class="priority-index">${duty.avgPriority.toFixed(2)}</span></td>
                        <td style="text-align: center;">${duty.highPriorityCount}</td>
                        <td style="text-align: center;"><strong style="color: #667eea;">${duty.trainingLoad.toFixed(2)}</strong></td>
                    </tr>
                `;
            }).join('');
            
            tableBody.innerHTML = rows;
        }
        
        // Export dashboard as CSV
        function exportDashboard() {
            if (collectionMode !== 'workshop') {
                showStatus('Dashboard export only available in Workshop mode', 'error');
                return;
            }
            
            // Get all valid results
            const validResults = [];
            
            Object.keys(workshopResults).forEach(taskKey => {
                const result = workshopResults[taskKey];
                if (result && result.valid) {
                    // Use stored duty and task titles (with backward compatibility)
                    let dutyText = result.dutyTitle;
                    let taskText = result.taskTitle;
                    
                    // Backward compatibility: if not stored, look up from DOM
                    if (!dutyText || !taskText) {
                        const taskParts = taskKey.split('_task_');
                        const dutyId = taskParts[0];
                        
                        if (!dutyText) {
                            const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                            dutyText = dutyInput ? dutyInput.value.trim() : 'Unassigned Duty';
                        }
                        
                        if (!taskText) {
                            const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                            taskText = taskInput ? taskInput.value.trim() : 'Unassigned Task';
                        }
                    }
                    
                    validResults.push({
                        duty: dutyText,
                        task: taskText,
                        meanImportance: result.meanImportance,
                        meanFrequency: result.meanFrequency,
                        meanDifficulty: result.meanDifficulty,
                        priorityIndex: result.priorityIndex
                    });
                }
            });
            
            // Sort by priority index (descending)
            validResults.sort((a, b) => b.priorityIndex - a.priorityIndex);
            
            // Build CSV
            let csv = 'Rank,Duty,Task,Mean Importance,Mean Frequency,Mean Difficulty,Priority Index\n';
            
            validResults.forEach((r, index) => {
                const rank = index + 1;
                csv += `${rank},"${r.duty.replace(/"/g, '""')}","${r.task.replace(/"/g, '""')}",${r.meanImportance.toFixed(2)},${r.meanFrequency.toFixed(2)},${r.meanDifficulty.toFixed(2)},${r.priorityIndex.toFixed(2)}\n`;
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            
            const occupationTitle = document.getElementById('occupationTitle').value || 'DACUM';
            const filename = `${occupationTitle.replace(/[^a-z0-9]/gi, '_')}_Workshop_Results_${new Date().toISOString().split('T')[0]}.csv`;
            link.download = filename;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showStatus('Dashboard exported as CSV successfully! âœ“', 'success');
        }

        // Attach click listeners to accordion headers
        function attachAccordionListeners() {
            const headers = document.querySelectorAll('.duty-accordion-header');
            
            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const isActive = this.classList.contains('active');
                    
                    // Close all accordions
                    document.querySelectorAll('.duty-accordion-header').forEach(h => {
                        h.classList.remove('active');
                    });
                    document.querySelectorAll('.duty-accordion-content').forEach(c => {
                        c.classList.remove('active');
                    });
                    
                    // Open clicked accordion if it wasn't active
                    if (!isActive) {
                        this.classList.add('active');
                        const content = this.nextElementSibling;
                        content.classList.add('active');
                    }
                });
            });
        }

        // Helper function to escape HTML (prevent XSS)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize verification tab when switching to it
        // This will be called automatically when tab is opened
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listener to verification tab
            const verificationTab = document.querySelector('[data-tab="verification-tab"]');
            if (verificationTab) {
                verificationTab.addEventListener('click', function() {
                    // Auto-load duties when tab is opened for the first time
                    const container = document.getElementById('verificationAccordionContainer');
                    if (container && container.children.length === 0) {
                        loadDutiesForVerification();
                    }
                });
            }
        });

        // ============ END TASK VERIFICATION FUNCTIONS ============

        // Clear all data
        function clearAll() {
            if (confirm('Are you sure you want to clear ALL data? This cannot be undone!')) {
                // Clear Chart Info
                document.getElementById('dacumDate').value = '';
                document.getElementById('producedFor').value = '';
                document.getElementById('producedBy').value = '';
                document.getElementById('occupationTitle').value = '';
                document.getElementById('jobTitle').value = '';
                document.getElementById('sector').value = '';
                document.getElementById('context').value = '';
                
                // Clear images
                producedForImage = null;
                producedByImage = null;
                document.getElementById('producedForImagePreview').innerHTML = '<span style="color: #999; font-size: 0.9em;">No image</span>';
                document.getElementById('producedForImagePreview').classList.remove('has-image');
                document.getElementById('producedByImagePreview').innerHTML = '<span style="color: #999; font-size: 0.9em;">No image</span>';
                document.getElementById('producedByImagePreview').classList.remove('has-image');
                document.getElementById('removeProducedForImage').style.display = 'none';
                document.getElementById('removeProducedByImage').style.display = 'none';
                document.getElementById('producedForImageInput').value = '';
                document.getElementById('producedByImageInput').value = '';
                
                // Clear all duties
                document.getElementById('dutiesContainer').innerHTML = '';
                dutyCount = 0;
                taskCounts = {};
                
                // Reset Additional Info headings
                document.getElementById('knowledgeHeading').textContent = 'Knowledge Requirements';
                document.getElementById('skillsHeading').textContent = 'Skills Requirements';
                document.getElementById('behaviorsHeading').textContent = 'Worker Behaviors/Traits';
                document.getElementById('toolsHeading').textContent = 'Tools, Equipment, Supplies and Materials';
                document.getElementById('trendsHeading').textContent = 'Future Trends and Concerns';
                document.getElementById('acronymsHeading').textContent = 'Acronyms';
                document.getElementById('careerPathHeading').textContent = 'Career Path';
                
                // Clear Additional Info textareas
                document.getElementById('knowledgeInput').value = '';
                document.getElementById('skillsInput').value = '';
                document.getElementById('behaviorsInput').value = '';
                document.getElementById('toolsInput').value = '';
                document.getElementById('trendsInput').value = '';
                document.getElementById('acronymsInput').value = '';
                document.getElementById('careerPathInput').value = '';
                
                // Clear all custom sections
                document.getElementById('customSectionsContainer').innerHTML = '';
                customSectionCounter = 0;
                
                // ============ CLEAR TASK VERIFICATION DATA (Bug Fix A) ============
                // Clear verification ratings
                verificationRatings = {};
                
                // Reset collection mode to default "workshop"
                collectionMode = 'workshop';
                document.getElementById('mode-workshop').checked = true;
                document.getElementById('mode-survey').checked = false;
                
                // Reset workflow mode to default "standard"
                workflowMode = 'standard';
                document.getElementById('workflow-standard').checked = true;
                document.getElementById('workflow-extended').checked = false;
                
                // Clear verification UI container
                const verificationContainer = document.getElementById('verificationAccordionContainer');
                if (verificationContainer) {
                    verificationContainer.innerHTML = '';
                    verificationContainer.classList.remove('workflow-extended');
                }
                
                // Clear workshop-specific data
                workshopParticipants = 10;
                workshopCounts = {};
                workshopResults = {};
                priorityFormula = 'if';
                document.getElementById('workshopParticipants').value = 10;
                document.getElementById('formula-if').checked = true;
                document.getElementById('formula-ifd').checked = false;
                
                // Clear dashboard
                const dashboardTableBody = document.getElementById('dashboardTableBody');
                if (dashboardTableBody) dashboardTableBody.innerHTML = '';
                const dashboardSummary = document.getElementById('dashboardSummary');
                if (dashboardSummary) dashboardSummary.innerHTML = '';
                
                console.log('Task Verification data cleared (including workshop data)');
                // ============ END VERIFICATION DATA CLEARING ============
                
                // Switch to Chart Info tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.querySelector('[data-tab="info-tab"]').classList.add('active');
                document.getElementById('info-tab').classList.add('active');
                
                showStatus('All data cleared! âœ“', 'success');
            }
        }

        // Save to JSON
        function saveToJSON() {
            try {
                const data = {
                    version: '1.0',
                    savedDate: new Date().toISOString(),
                    chartInfo: {
                        dacumDate: document.getElementById('dacumDate').value,
                        producedFor: document.getElementById('producedFor').value,
                        producedBy: document.getElementById('producedBy').value,
                        occupationTitle: document.getElementById('occupationTitle').value,
                        jobTitle: document.getElementById('jobTitle').value,
                        sector: document.getElementById('sector').value,
                        context: document.getElementById('context').value,
                        producedForImage: producedForImage,
                        producedByImage: producedByImage
                    },
                    duties: [],
                    additionalInfo: {
                        headings: {
                            knowledge: document.getElementById('knowledgeHeading').textContent,
                            skills: document.getElementById('skillsHeading').textContent,
                            behaviors: document.getElementById('behaviorsHeading').textContent,
                            tools: document.getElementById('toolsHeading').textContent,
                            trends: document.getElementById('trendsHeading').textContent,
                            acronyms: document.getElementById('acronymsHeading').textContent,
                            careerPath: document.getElementById('careerPathHeading').textContent
                        },
                        knowledge: document.getElementById('knowledgeInput').value,
                        skills: document.getElementById('skillsInput').value,
                        behaviors: document.getElementById('behaviorsInput').value,
                        tools: document.getElementById('toolsInput').value,
                        trends: document.getElementById('trendsInput').value,
                        acronyms: document.getElementById('acronymsInput').value,
                        careerPath: document.getElementById('careerPathInput').value
                    },
                    customSections: []
                };

                // Collect duties and tasks
                const dutyInputs = document.querySelectorAll('[data-duty-id]');
                dutyInputs.forEach(dutyInput => {
                    const dutyText = dutyInput.value.trim();
                    const dutyId = dutyInput.getAttribute('data-duty-id');
                    const taskInputs = document.querySelectorAll(`[data-task-id^="${dutyId}_"]`);
                    const tasks = [];
                    
                    taskInputs.forEach(taskInput => {
                        const taskText = taskInput.value.trim();
                        if (taskText) {
                            tasks.push(taskText);
                        }
                    });
                    
                    data.duties.push({
                        duty: dutyText,
                        tasks: tasks
                    });
                });

                // Collect custom sections
                const customSectionsContainer = document.getElementById('customSectionsContainer');
                const customSectionDivs = customSectionsContainer.querySelectorAll('.section-container');
                customSectionDivs.forEach(sectionDiv => {
                    const headingElement = sectionDiv.querySelector('h3');
                    const textareaElement = sectionDiv.querySelector('textarea');
                    if (headingElement && textareaElement) {
                        data.customSections.push({
                            heading: headingElement.textContent,
                            content: textareaElement.value
                        });
                    }
                });

                // Collect verification ratings (includes workflow mode and workshop data)
                data.verification = {
                    collectionMode: collectionMode,
                    workflowMode: workflowMode,
                    ratings: verificationRatings,
                    taskMetadata: taskMetadata,
                    // Workshop-specific data
                    workshopParticipants: workshopParticipants,
                    priorityFormula: priorityFormula,
                    trainingLoadMethod: trainingLoadMethod,
                    workshopCounts: workshopCounts,
                    workshopResults: workshopResults
                };

                // Create JSON file and download
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                
                const filename = data.chartInfo.occupationTitle || 'DACUM_Chart';
                link.download = `${filename.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showStatus('Data saved successfully! âœ“', 'success');
            } catch (error) {
                console.error('Error saving data:', error);
                showStatus('Error saving data: ' + error.message, 'error');
            }
        }

        // Load from JSON
        function loadFromJSON(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Load chart info
                        if (data.chartInfo) {
                            document.getElementById('dacumDate').value = data.chartInfo.dacumDate || '';
                            document.getElementById('producedFor').value = data.chartInfo.producedFor || '';
                            document.getElementById('producedBy').value = data.chartInfo.producedBy || '';
                            document.getElementById('occupationTitle').value = data.chartInfo.occupationTitle || '';
                            document.getElementById('jobTitle').value = data.chartInfo.jobTitle || '';
                            document.getElementById('sector').value = data.chartInfo.sector || '';
                            document.getElementById('context').value = data.chartInfo.context || '';
                            
                            // Restore images
                            if (data.chartInfo.producedForImage) {
                                producedForImage = data.chartInfo.producedForImage;
                                document.getElementById('producedForImagePreview').innerHTML = `<img src="${producedForImage}" alt="Produced For logo">`;
                                document.getElementById('producedForImagePreview').classList.add('has-image');
                                document.getElementById('removeProducedForImage').style.display = 'inline-block';
                            }
                            
                            if (data.chartInfo.producedByImage) {
                                producedByImage = data.chartInfo.producedByImage;
                                document.getElementById('producedByImagePreview').innerHTML = `<img src="${producedByImage}" alt="Produced By logo">`;
                                document.getElementById('producedByImagePreview').classList.add('has-image');
                                document.getElementById('removeProducedByImage').style.display = 'inline-block';
                            }
                        }

                        // Clear existing duties
                        document.getElementById('dutiesContainer').innerHTML = '';
                        dutyCount = 0;
                        taskCounts = {};

                        // Load duties and tasks
                        if (data.duties && Array.isArray(data.duties)) {
                            data.duties.forEach(dutyData => {
                                addDuty();
                                const currentDutyId = `duty_${dutyCount}`;
                                const dutyInput = document.querySelector(`[data-duty-id="${currentDutyId}"]`);
                                if (dutyInput) {
                                    dutyInput.value = dutyData.duty || '';
                                }

                                // Add tasks
                                if (dutyData.tasks && Array.isArray(dutyData.tasks)) {
                                    dutyData.tasks.forEach((taskData, taskIndex) => {
                                        addTask(currentDutyId);
                                        const taskInputs = document.querySelectorAll(`[data-task-id^="${currentDutyId}_"]`);
                                        const lastTaskInput = taskInputs[taskInputs.length - 1];
                                        if (lastTaskInput) {
                                            // Handle both Schema A (string) and Schema B (object with voting metrics)
                                            let taskText = '';
                                            if (typeof taskData === 'string') {
                                                // Schema A: pre-vote format (string)
                                                taskText = taskData;
                                            } else if (typeof taskData === 'object' && taskData !== null) {
                                                // Schema B: post-vote format (object with metrics)
                                                taskText = taskData.task || taskData.text || taskData.title || '';
                                                
                                                // Preserve voting metrics if present
                                                if (taskData.meanImportance !== undefined) {
                                                    const taskId = lastTaskInput.getAttribute('data-task-id');
                                                    if (!window.importedVotingResults) {
                                                        window.importedVotingResults = {};
                                                    }
                                                    window.importedVotingResults[taskId] = {
                                                        meanImportance: taskData.meanImportance,
                                                        meanFrequency: taskData.meanFrequency,
                                                        meanDifficulty: taskData.meanDifficulty,
                                                        priorityIndex: taskData.priorityIndex,
                                                        rank: taskData.rank
                                                    };
                                                }
                                            }
                                            lastTaskInput.value = taskText;
                                        }
                                    });
                                }
                            });
                        }

                        // Load additional info
                        if (data.additionalInfo) {
                            // Load custom headings
                            if (data.additionalInfo.headings) {
                                document.getElementById('knowledgeHeading').textContent = data.additionalInfo.headings.knowledge || 'Knowledge Requirements';
                                document.getElementById('skillsHeading').textContent = data.additionalInfo.headings.skills || 'Skills Requirements';
                                document.getElementById('behaviorsHeading').textContent = data.additionalInfo.headings.behaviors || 'Worker Behaviors/Traits';
                                document.getElementById('toolsHeading').textContent = data.additionalInfo.headings.tools || 'Tools, Equipment, Supplies and Materials';
                                document.getElementById('trendsHeading').textContent = data.additionalInfo.headings.trends || 'Future Trends and Concerns';
                                document.getElementById('acronymsHeading').textContent = data.additionalInfo.headings.acronyms || 'Acronyms';
                                document.getElementById('careerPathHeading').textContent = data.additionalInfo.headings.careerPath || 'Career Path';
                            }

                            // Load text areas
                            document.getElementById('knowledgeInput').value = data.additionalInfo.knowledge || '';
                            document.getElementById('skillsInput').value = data.additionalInfo.skills || '';
                            document.getElementById('behaviorsInput').value = data.additionalInfo.behaviors || '';
                            document.getElementById('toolsInput').value = data.additionalInfo.tools || '';
                            document.getElementById('trendsInput').value = data.additionalInfo.trends || '';
                            document.getElementById('acronymsInput').value = data.additionalInfo.acronyms || '';
                            document.getElementById('careerPathInput').value = data.additionalInfo.careerPath || '';
                        }

                        // Clear and load custom sections
                        document.getElementById('customSectionsContainer').innerHTML = '';
                        customSectionCounter = 0;
                        
                        if (data.customSections && Array.isArray(data.customSections)) {
                            data.customSections.forEach(section => {
                                addCustomSection();
                                const lastSection = document.getElementById('customSectionsContainer').lastElementChild;
                                if (lastSection) {
                                    const headingElement = lastSection.querySelector('h3');
                                    const textareaElement = lastSection.querySelector('textarea');
                                    if (headingElement) headingElement.textContent = section.heading;
                                    if (textareaElement) textareaElement.value = section.content;
                                }
                            });
                        }

                        // Load verification data (with backward compatibility for v3.1)
                        if (data.verification) {
                            collectionMode = data.verification.collectionMode || 'workshop';
                            // Backward compatible: if workflowMode not present, default to 'standard'
                            workflowMode = data.verification.workflowMode || 'standard';
                            verificationRatings = data.verification.ratings || {};
                            taskMetadata = data.verification.taskMetadata || {};
                            
                            // Update UI to reflect loaded collection mode
                            if (collectionMode === 'workshop') {
                                document.getElementById('mode-workshop').checked = true;
                            } else if (collectionMode === 'survey') {
                                document.getElementById('mode-survey').checked = true;
                            }
                            
                            // Update UI to reflect loaded workflow mode
                            if (workflowMode === 'standard') {
                                document.getElementById('workflow-standard').checked = true;
                                document.getElementById('workflow-extended').checked = false;
                            } else if (workflowMode === 'extended') {
                                document.getElementById('workflow-standard').checked = false;
                                document.getElementById('workflow-extended').checked = true;
                            }
                            
                            // Apply workflow mode class to container
                            const verificationContainer = document.getElementById('verificationAccordionContainer');
                            if (verificationContainer) {
                                if (workflowMode === 'extended') {
                                    verificationContainer.classList.add('workflow-extended');
                                } else {
                                    verificationContainer.classList.remove('workflow-extended');
                                }
                            }
                            
                            console.log('Loaded verification data:', {
                                collectionMode: collectionMode,
                                workflowMode: workflowMode,
                                ratingsCount: Object.keys(verificationRatings).length
                            });
                            
                            // Load workshop-specific data (backward compatible)
                            if (data.verification.workshopParticipants) {
                                workshopParticipants = data.verification.workshopParticipants;
                                document.getElementById('workshopParticipants').value = workshopParticipants;
                            }
                            
                            if (data.verification.priorityFormula) {
                                priorityFormula = data.verification.priorityFormula;
                                if (priorityFormula === 'if') {
                                    document.getElementById('formula-if').checked = true;
                                } else {
                                    document.getElementById('formula-ifd').checked = true;
                                }
                            }
                            
                            if (data.verification.trainingLoadMethod) {
                                trainingLoadMethod = data.verification.trainingLoadMethod;
                                const radioAdvanced = document.querySelector('input[name="trainingLoadMethod"][value="advanced"]');
                                const radioSimple = document.querySelector('input[name="trainingLoadMethod"][value="simple"]');
                                if (trainingLoadMethod === 'advanced' && radioAdvanced) {
                                    radioAdvanced.checked = true;
                                } else if (trainingLoadMethod === 'simple' && radioSimple) {
                                    radioSimple.checked = true;
                                }
                                // Update label
                                const label = document.getElementById('trainingLoadMethodLabel');
                                if (label) {
                                    label.innerHTML = `Current Method: <strong style="color: #667eea;">${trainingLoadMethod === 'advanced' ? 'Advanced' : 'Simple'}</strong>`;
                                }
                            }
                            
                            if (data.verification.workshopCounts) {
                                workshopCounts = data.verification.workshopCounts;
                            }
                            
                            if (data.verification.workshopResults) {
                                workshopResults = data.verification.workshopResults;
                            }
                            
                            // Backward compatibility: If taskMetadata is empty, rebuild it from DOM
                            if (Object.keys(taskMetadata).length === 0 && Object.keys(verificationRatings).length > 0) {
                                Object.keys(verificationRatings).forEach(taskKey => {
                                    const taskParts = taskKey.split('_task_');
                                    const dutyId = taskParts[0];
                                    const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                                    const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                                    
                                    if (dutyInput && taskInput) {
                                        taskMetadata[taskKey] = {
                                            dutyId: dutyId,
                                            dutyTitle: dutyInput.value.trim(),
                                            taskTitle: taskInput.value.trim()
                                        };
                                    }
                                });
                            }
                            
                            // Show/hide workshop-specific UI elements based on loaded mode
                            const workshopSection = document.getElementById('workshopParticipantsSection');
                            const dashboardSection = document.getElementById('resultsDashboard');
                            const priorityFormulaSection = document.getElementById('priorityFormulaSection');
                            
                            if (collectionMode === 'workshop') {
                                if (workshopSection) workshopSection.style.display = 'block';
                                if (dashboardSection) dashboardSection.style.display = 'block';
                                if (priorityFormulaSection && workflowMode === 'standard') {
                                    priorityFormulaSection.style.display = 'block';
                                }
                                // Refresh dashboard after loading
                                setTimeout(() => refreshDashboard(), 500);
                            }
                            
                            console.log('Workshop data loaded:', {
                                participants: workshopParticipants,
                                formula: priorityFormula,
                                countsKeys: Object.keys(workshopCounts).length,
                                resultsKeys: Object.keys(workshopResults).length
                            });
                        }

                        // Switch to Chart Info tab
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        document.querySelector('[data-tab="info-tab"]').classList.add('active');
                        document.getElementById('info-tab').classList.add('active');

                        showStatus('Data loaded successfully! âœ“', 'success');
                        
                        // Reset file input
                        event.target.value = '';
                    } catch (parseError) {
                        console.error('Error parsing JSON:', parseError);
                        showStatus('Error: Invalid JSON file', 'error');
                    }
                };
                reader.readAsText(file);
            } catch (error) {
                console.error('Error loading file:', error);
                showStatus('Error loading file: ' + error.message, 'error');
            }
        }

        // Export to Word (DOCX)
        // ============ STANDALONE TASK VERIFICATION WORD EXPORT ============
        async function exportTaskVerificationWord() {
            try {
                // Check if we have Task Verification data
                if (collectionMode !== 'workshop' || !workshopResults || Object.keys(workshopResults).length === 0) {
                    alert('No Task Verification data available. Please complete workshop counts in the Task Verification tab first.');
                    return;
                }
                
                const validResults = Object.keys(workshopResults).filter(key => 
                    workshopResults[key] && workshopResults[key].valid
                );
                
                if (validResults.length === 0) {
                    alert('No valid Task Verification results. Please ensure all required fields are completed.');
                    return;
                }
                
                if (typeof window.docx === 'undefined') {
                    showStatus('Error: Word export library not loaded. Please refresh the page.', 'error');
                    return;
                }

                const { Document, Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, ShadingType, Packer } = window.docx;

                showStatus('Generating Task Verification Word document...', 'success');

                const children = [];
                
                const occupationTitleInput = document.getElementById('occupationTitle');
                const occupationTitle = occupationTitleInput ? occupationTitleInput.value : 'Unknown Occupation';
                
                // Title
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: 'Task Verification & Training Priority Analysis',
                            bold: true,
                            size: 32,
                        }),
                    ],
                    spacing: { after: 300 },
                    bidirectional: false, // Force LTR
                }));
                
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `Occupation: ${occupationTitle}`,
                            bold: true,
                            size: 28,
                        }),
                    ],
                    spacing: { after: 200 },
                    bidirectional: false, // Force LTR
                }));
                
                const today = new Date().toLocaleDateString();
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `Date of Analysis: ${today}`,
                            size: 24,
                        }),
                    ],
                    spacing: { after: 200 },
                    bidirectional: false, // Force LTR
                }));
                
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `This Task Verification is based on the DACUM Chart for ${occupationTitle}.`,
                            italics: true,
                            size: 20,
                        }),
                    ],
                    spacing: { after: 400 },
                    bidirectional: false, // Force LTR
                }));
                
                // Methodology Summary
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: 'Methodology Summary',
                            bold: true,
                            size: 28,
                        }),
                    ],
                    spacing: { after: 200 },
                    bidirectional: false, // Force LTR
                }));
                
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `Data Collection Mode: ${collectionMode === 'workshop' ? 'Workshop (Facilitated)' : 'Individual/Survey'}`,
                            size: 22,
                        }),
                    ],
                    spacing: { after: 100 },
                    bidirectional: false, // Force LTR
                }));
                
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `Number of Participants: ${workshopParticipants}`,
                            size: 22,
                        }),
                    ],
                    spacing: { after: 100 },
                    bidirectional: false, // Force LTR
                }));
                
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `Workflow Mode: ${workflowMode === 'standard' ? 'Standard (DACUM)' : 'Extended (DACUM)'}`,
                            size: 22,
                        }),
                    ],
                    spacing: { after: 100 },
                    bidirectional: false, // Force LTR
                }));
                
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `Priority Formula: ${priorityFormula === 'if' ? 'Importance Ã— Frequency' : 'Importance Ã— Frequency Ã— Difficulty'}`,
                            size: 22,
                        }),
                    ],
                    spacing: { after: 400 },
                    bidirectional: false, // Force LTR
                }));
                
                // Priority Rankings
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: 'Priority Rankings',
                            bold: true,
                            size: 28,
                        }),
                    ],
                    spacing: { after: 200 },
                    bidirectional: false, // Force LTR
                }));
                
                // Get and sort results
                const sortedResults = [];
                validResults.forEach(taskKey => {
                    const result = workshopResults[taskKey];
                    
                    // Use stored duty and task titles (with backward compatibility)
                    let dutyText = result.dutyTitle;
                    let taskText = result.taskTitle;
                    
                    // Backward compatibility: if not stored, look up from DOM
                    if (!dutyText || !taskText) {
                        const taskParts = taskKey.split('_task_');
                        const dutyId = taskParts[0];
                        
                        if (!dutyText) {
                            const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                            dutyText = dutyInput ? dutyInput.value.trim() : 'Unassigned';
                        }
                        
                        if (!taskText) {
                            const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                            taskText = taskInput ? taskInput.value.trim() : 'Unassigned';
                        }
                    }
                    
                    sortedResults.push({
                        duty: dutyText,
                        task: taskText,
                        meanI: result.meanImportance,
                        meanF: result.meanFrequency,
                        meanD: result.meanDifficulty,
                        priority: result.priorityIndex
                    });
                });
                
                sortedResults.sort((a, b) => b.priority - a.priority);
                
                // Create table
                const tableRows = [];
                
                // Header row
                tableRows.push(new TableRow({
                    children: [
                        new TableCell({
                            children: [new Paragraph({ children: [new TextRun({ text: 'Rank', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                            shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                        }),
                        new TableCell({
                            children: [new Paragraph({ children: [new TextRun({ text: 'Duty', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                            shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                        }),
                        new TableCell({
                            children: [new Paragraph({ children: [new TextRun({ text: 'Task', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                            shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                        }),
                        new TableCell({
                            children: [new Paragraph({ children: [new TextRun({ text: 'Mean I', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                            shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                        }),
                        new TableCell({
                            children: [new Paragraph({ children: [new TextRun({ text: 'Mean F', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                            shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                        }),
                        new TableCell({
                            children: [new Paragraph({ children: [new TextRun({ text: 'Mean D', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                            shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                        }),
                        new TableCell({
                            children: [new Paragraph({ children: [new TextRun({ text: 'Priority', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                            shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                        }),
                    ],
                }));
                
                // Data rows
                sortedResults.forEach((row, index) => {
                    tableRows.push(new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: `#${index + 1}` })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                            new TableCell({ children: [new Paragraph({ text: row.duty, bidirectional: false })] }),
                            new TableCell({ children: [new Paragraph({ text: row.task, bidirectional: false })] }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: row.meanI !== null ? row.meanI.toFixed(2) : 'N/A' })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: row.meanF !== null ? row.meanF.toFixed(2) : 'N/A' })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: row.meanD !== null ? row.meanD.toFixed(2) : 'N/A' })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: row.priority !== null ? row.priority.toFixed(2) : 'N/A' })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                        ],
                    }));
                });
                
                children.push(new Table({
                    width: { size: 100, type: WidthType.PERCENTAGE },
                    rows: tableRows,
                }));
                
                // Duty-Level Summary section
                children.push(new Paragraph({ spacing: { after: 400 } }));
                
                children.push(new Paragraph({
                    children: [new TextRun({ text: 'Duty-Level Summary', bold: true, size: 28 })],
                    spacing: { after: 200 },
                    bidirectional: false,
                }));
                
                children.push(new Paragraph({
                    children: [new TextRun({ text: `Training Load Method: ${trainingLoadMethod === 'advanced' ? 'Advanced (Î£ Priority Ã— Difficulty)' : 'Simple (Avg Priority Ã— Tasks)'}`, size: 20, italics: true })],
                    spacing: { after: 200 },
                    bidirectional: false,
                }));
                
                // Aggregate duty-level data
                const dutyMap = {};
                Object.keys(workshopResults).forEach(taskKey => {
                    const result = workshopResults[taskKey];
                    if (result && result.valid) {
                        let dutyId = result.dutyId || taskKey.split('_task_')[0];
                        let dutyTitle = result.dutyTitle;
                        
                        if (!dutyTitle) {
                            const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                            dutyTitle = dutyInput ? dutyInput.value.trim() : 'Unassigned';
                        }
                        
                        if (!dutyMap[dutyId]) {
                            dutyMap[dutyId] = { dutyTitle: dutyTitle, validTasks: 0, prioritySum: 0, tasks: [] };
                        }
                        
                        dutyMap[dutyId].validTasks++;
                        dutyMap[dutyId].prioritySum += result.priorityIndex;
                        dutyMap[dutyId].tasks.push({ priorityIndex: result.priorityIndex, meanDifficulty: result.meanDifficulty });
                    }
                });
                
                const dutyResults = [];
                Object.keys(dutyMap).forEach(dutyId => {
                    const duty = dutyMap[dutyId];
                    const avgPriority = duty.prioritySum / duty.validTasks;
                    let trainingLoad = 0;
                    if (trainingLoadMethod === 'advanced') {
                        trainingLoad = duty.tasks.reduce((sum, t) => sum + (t.priorityIndex * t.meanDifficulty), 0);
                    } else {
                        trainingLoad = avgPriority * duty.validTasks;
                    }
                    dutyResults.push({ dutyTitle: duty.dutyTitle, validTasks: duty.validTasks, avgPriority: avgPriority, trainingLoad: trainingLoad });
                });
                
                dutyResults.sort((a, b) => b.avgPriority - a.avgPriority);
                
                // Duty table
                const dutyTableRows = [
                    new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: 'Duty Title', bold: true })], alignment: AlignmentType.LEFT, bidirectional: false })], shading: { fill: '667eea' } }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: 'Tasks', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })], shading: { fill: '667eea' } }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: 'Avg Priority', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })], shading: { fill: '667eea' } }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: 'Training Load', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })], shading: { fill: '667eea' } }),
                        ],
                    })
                ];
                
                dutyResults.forEach(duty => {
                    dutyTableRows.push(new TableRow({
                        children: [
                            new TableCell({ children: [new Paragraph({ text: duty.dutyTitle, bidirectional: false })], verticalAlign: VerticalAlign.CENTER }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: duty.validTasks.toString() })], alignment: AlignmentType.CENTER, bidirectional: false })], verticalAlign: VerticalAlign.CENTER }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: duty.avgPriority.toFixed(2) })], alignment: AlignmentType.CENTER, bidirectional: false })], verticalAlign: VerticalAlign.CENTER }),
                            new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: duty.trainingLoad.toFixed(2), bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })], verticalAlign: VerticalAlign.CENTER }),
                        ],
                    }));
                });
                
                children.push(new Table({
                    width: { size: 100, type: WidthType.PERCENTAGE },
                    rows: dutyTableRows,
                }));
                
                // Notes section
                children.push(new Paragraph({ spacing: { after: 400 } }));
                
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: 'Notes & Methodology',
                            bold: true,
                            size: 24,
                        }),
                    ],
                    spacing: { after: 200 },
                    bidirectional: false, // Force LTR
                }));
                
                const notes = [
                    'Weighted Mean = Î£(value Ã— count) Ã· total responses',
                    'Importance scale: 0=Not Important, 1=Somewhat, 2=Important, 3=Critical',
                    'Frequency scale: 0=Rarely, 1=Sometimes, 2=Often, 3=Daily',
                    'Difficulty scale: 0=Easy, 1=Moderate, 2=Challenging, 3=Very Difficult',
                    `Priority Index = ${priorityFormula === 'if' ? 'Mean Importance Ã— Mean Frequency' : 'Mean Importance Ã— Mean Frequency Ã— Mean Difficulty'}`,
                    'Higher priority values indicate greater training importance',
                    'Results follow DACUM (Developing A Curriculum) methodology'
                ];
                
                notes.forEach(note => {
                    children.push(new Paragraph({
                        children: [
                            new TextRun({
                                text: `â€¢ ${note}`,
                                size: 20,
                            }),
                        ],
                        spacing: { after: 100 },
                        bidirectional: false, // Force LTR
                    }));
                });
                
                // Create document
                const doc = new Document({
                    sections: [{
                        properties: {
                            page: {
                                margin: {
                                    top: 1440,
                                    right: 1440,
                                    bottom: 1440,
                                    left: 1440,
                                },
                            },
                        },
                        children: children,
                    }],
                });

                // Generate and download
                const blob = await Packer.toBlob(doc);
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${occupationTitle.replace(/[^a-z0-9]/gi, '_')}_Task_Verification.docx`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showStatus('Task Verification Word document exported successfully! âœ“', 'success');

            } catch (error) {
                console.error('Error generating Task Verification Word document:', error);
                showStatus('Error generating Task Verification Word document: ' + error.message, 'error');
            }
        }

        async function exportToWord() {
            // ============ CHECK FOR VERIFIED LIVE WORKSHOP RESULTS ============
            const hasVerifiedResults = typeof lwFinalizedData !== 'undefined' && lwFinalizedData && 
                                        typeof lwAggregatedResults !== 'undefined' && lwAggregatedResults;
            
            // ============ VERIFIED LIVE WORKSHOP STANDALONE EXPORT ============
            if (hasVerifiedResults && tvExportMode === 'standalone') {
                await lwExportVerifiedDOCX();
                return;
            }
            
            // ============ REGULAR TASK VERIFICATION STANDALONE EXPORT ============
            if (!hasVerifiedResults && tvExportMode === 'standalone') {
                await exportTaskVerificationWord();
                return;
            }
            
            // ============ NORMAL DACUM EXPORT (with optional appendix) ============
            try {
                if (typeof window.docx === 'undefined') {
                    showStatus('Error: Word export library not loaded. Please refresh the page.', 'error');
                    return;
                }

                const { Document, Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, BorderStyle, Packer, PageBreak, convertInchesToTwip, ShadingType, TextDirection, ImageRun } = window.docx;

                // Get all input values
                const dacumDateValue = document.getElementById('dacumDate').value;
                let dacumDate = '';
                if (dacumDateValue) {
                    const dateObj = new Date(dacumDateValue + 'T00:00:00');
                    const month = String(dateObj.getMonth() + 1).padStart(2, '0');
                    const day = String(dateObj.getDate()).padStart(2, '0');
                    const year = dateObj.getFullYear();
                    dacumDate = `${month}/${day}/${year}`;
                }
                const producedFor = document.getElementById('producedFor').value;
                const producedBy = document.getElementById('producedBy').value;
                const occupationTitle = document.getElementById('occupationTitle').value;
                const jobTitle = document.getElementById('jobTitle').value;

                if (!occupationTitle || !jobTitle) {
                    showStatus('Please fill in at least the Occupation Title and Job Title', 'error');
                    return;
                }

                showStatus('Generating Word document...', 'success');

                const children = [];

                // ============ TITLE PAGE ============
                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `Occupation Title: ${occupationTitle}`,
                            bold: true,
                            size: 28, // 14pt
                        }),
                    ],
                    spacing: { after: 200 },
                    bidirectional: false,
                }));

                children.push(new Paragraph({
                    children: [
                        new TextRun({
                            text: `Job Title: ${jobTitle}`,
                            bold: true,
                            size: 28, // 14pt
                        }),
                    ],
                    spacing: { after: 200 },
                    bidirectional: false,
                }));

                // Add DACUM Date if exists
                if (dacumDate) {
                    children.push(new Paragraph({
                        children: [
                            new TextRun({
                                text: `DACUM Date: ${dacumDate}`,
                                bold: true,
                                size: 24, // 12pt
                            }),
                        ],
                        spacing: { after: 200 },
                        bidirectional: false,
                    }));
                }

                // Add Produced For if exists
                if (producedFor) {
                    children.push(new Paragraph({
                        children: [
                            new TextRun({
                                text: `Produced For: ${producedFor}`,
                                bold: true,
                                size: 24, // 12pt
                            }),
                        ],
                        spacing: { after: 200 },
                        bidirectional: false,
                    }));
                    
                    // Add Produced For logo if exists
                    if (producedForImage) {
                        try {
                            const base64Data = producedForImage.split(',')[1];
                            
                            children.push(new Paragraph({
                                children: [
                                    new ImageRun({
                                        data: Uint8Array.from(atob(base64Data), c => c.charCodeAt(0)),
                                        transformation: {
                                            width: 94, // 2.5cm = 94 points approximately
                                            height: 94,
                                        },
                                    }),
                                ],
                                alignment: AlignmentType.CENTER,
                                spacing: { after: 200 },
                            }));
                        } catch (imgError) {
                            console.error('Error adding Produced For image:', imgError);
                        }
                    }
                }

                // Add Produced By if exists
                if (producedBy) {
                    children.push(new Paragraph({
                        children: [
                            new TextRun({
                                text: `Produced By: ${producedBy}`,
                                bold: true,
                                size: 24, // 12pt
                            }),
                        ],
                        spacing: { after: 200 },
                        bidirectional: false,
                    }));
                    
                    // Add Produced By logo if exists
                    if (producedByImage) {
                        try {
                            const base64Data = producedByImage.split(',')[1];
                            
                            children.push(new Paragraph({
                                children: [
                                    new ImageRun({
                                        data: Uint8Array.from(atob(base64Data), c => c.charCodeAt(0)),
                                        transformation: {
                                            width: 94, // 2.5cm = 94 points approximately
                                            height: 94,
                                        },
                                    }),
                                ],
                                alignment: AlignmentType.CENTER,
                                spacing: { after: 400 },
                            }));
                        } catch (imgError) {
                            console.error('Error adding Produced By image:', imgError);
                        }
                    }
                } else {
                    // Add extra spacing if no Produced By section
                    children.push(new Paragraph({ spacing: { after: 200 } }));
                }

                // ============ DUTIES AND TASKS (NEW PAGE) ============
                children.push(new Paragraph({
                    children: [
                        new PageBreak(),
                        new TextRun({
                            text: 'Duties and Tasks',
                            bold: true,
                            size: 28, // 14pt
                        }),
                    ],
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 300 },
                    bidirectional: false,
                }));

                // Collect duties and tasks
                const dutyInputs = document.querySelectorAll('[data-duty-id]');
                const duties = [];
                
                dutyInputs.forEach(dutyInput => {
                    const dutyText = dutyInput.value.trim();
                    if (dutyText) {
                        const dutyId = dutyInput.getAttribute('data-duty-id');
                        const taskInputs = document.querySelectorAll(`[data-task-id^="${dutyId}_"]`);
                        const tasks = [];
                        
                        taskInputs.forEach(taskInput => {
                            const taskText = taskInput.value.trim();
                            if (taskText) {
                                tasks.push(taskText);
                            }
                        });
                        
                        duties.push({
                            duty: dutyText,
                            tasks: tasks
                        });
                    }
                });

                // Create a table for each duty
                duties.forEach((dutyData, dutyIndex) => {
                    const dutyLetter = String.fromCharCode(65 + dutyIndex); // A, B, C...
                    const dutyLabel = `DUTY ${dutyLetter}: ${dutyData.duty}`;
                    
                    // Calculate number of rows needed (header + task rows)
                    const tasksPerRow = 4;
                    const numTaskRows = Math.ceil(dutyData.tasks.length / tasksPerRow);
                    const tableRows = [];
                    
                    // Header row (duty description spans all 4 columns)
                    tableRows.push(
                        new TableRow({
                            children: [
                                new TableCell({
                                    children: [
                                        new Paragraph({
                                            children: [
                                                new TextRun({
                                                    text: dutyLabel,
                                                    bold: true,
                                                    size: 24, // 12pt
                                                }),
                                            ],
                                            bidirectional: false,
                                        }),
                                    ],
                                    columnSpan: 4,
                                    shading: {
                                        fill: "E8E8E8", // Light gray
                                        type: ShadingType.SOLID,
                                    },
                                    width: {
                                        size: 100,
                                        type: WidthType.PERCENTAGE,
                                    },
                                }),
                            ],
                        })
                    );
                    
                    // Task rows (4 tasks per row)
                    for (let row = 0; row < numTaskRows; row++) {
                        const rowCells = [];
                        
                        for (let col = 0; col < tasksPerRow; col++) {
                            const taskIndex = row * tasksPerRow + col;
                            
                            if (taskIndex < dutyData.tasks.length) {
                                const taskLabel = `Task ${dutyLetter}${taskIndex + 1}`;
                                const taskText = `${taskLabel}: ${dutyData.tasks[taskIndex]}`;
                                
                                rowCells.push(
                                    new TableCell({
                                        children: [
                                            new Paragraph({
                                                children: [
                                                    new TextRun({
                                                        text: taskText,
                                                        size: 24, // 12pt
                                                    }),
                                                ],
                                                bidirectional: false,
                                            }),
                                        ],
                                        width: {
                                            size: 25,
                                            type: WidthType.PERCENTAGE,
                                        },
                                    })
                                );
                            } else {
                                // Empty cell
                                rowCells.push(
                                    new TableCell({
                                        children: [new Paragraph('')],
                                        width: {
                                            size: 25,
                                            type: WidthType.PERCENTAGE,
                                        },
                                    })
                                );
                            }
                        }
                        
                        tableRows.push(new TableRow({ children: rowCells }));
                    }
                    
                    // Create the table with 16cm width
                    children.push(
                        new Table({
                            width: {
                                size: 9071, // 16cm in twips (16 * 567.05 â‰ˆ 9071)
                                type: WidthType.DXA,
                            },
                            layout: "fixed", // Fixed table layout for consistent width
                            rows: tableRows,
                        })
                    );
                    
                    // Add spacing after table
                    children.push(new Paragraph({ spacing: { after: 200 } }));
                });

                // ============ ADDITIONAL INFORMATION (NEW PAGE) ============
                children.push(new Paragraph({
                    children: [
                        new PageBreak(),
                        new TextRun({
                            text: 'Additional Information',
                            bold: true,
                            size: 24, // 12pt
                        }),
                    ],
                    spacing: { after: 300 },
                    bidirectional: false,
                }));

                // Create 2-column tables for additional info
                const additionalInfoSections = [
                    {
                        heading1: document.getElementById('knowledgeHeading').textContent,
                        content1: document.getElementById('knowledgeInput').value.trim(),
                        heading2: document.getElementById('behaviorsHeading').textContent,
                        content2: document.getElementById('behaviorsInput').value.trim(),
                    },
                    {
                        heading1: document.getElementById('skillsHeading').textContent,
                        content1: document.getElementById('skillsInput').value.trim(),
                        heading2: '', // Empty for single column
                        content2: '',
                    },
                    {
                        heading1: document.getElementById('toolsHeading').textContent,
                        content1: document.getElementById('toolsInput').value.trim(),
                        heading2: document.getElementById('trendsHeading').textContent,
                        content2: document.getElementById('trendsInput').value.trim(),
                    },
                    {
                        heading1: document.getElementById('acronymsHeading').textContent,
                        content1: document.getElementById('acronymsInput').value.trim(),
                        heading2: document.getElementById('careerPathHeading').textContent,
                        content2: document.getElementById('careerPathInput').value.trim(),
                    },
                ];

                additionalInfoSections.forEach((section, index) => {
                    // Special handling for Acronyms (index 3, content1) - separate table with heading in first cell
                    if (index === 3 && section.content1) {
                        const row = new TableRow({
                            children: [
                                // First cell: Heading only with gray background
                                new TableCell({
                                    children: [
                                        new Paragraph({
                                            children: [
                                                new TextRun({
                                                    text: section.heading1,
                                                    bold: true,
                                                    size: 24, // 12pt
                                                }),
                                            ],
                                            bidirectional: false,
                                        }),
                                    ],
                                    shading: {
                                        fill: "E8E8E8", // Light gray background
                                        type: ShadingType.SOLID,
                                    },
                                    width: {
                                        size: 30,
                                        type: WidthType.PERCENTAGE,
                                    },
                                }),
                                // Second cell: Content only
                                new TableCell({
                                    children: section.content1.split('\n').filter(line => line.trim()).map(line => 
                                        new Paragraph({
                                            children: [
                                                new TextRun({
                                                    text: line.trim().replace(/^[â€¢\-*]\s*/, 'â€¢ '),
                                                    size: 24, // 12pt
                                                }),
                                            ],
                                            bidirectional: false,
                                        })
                                    ),
                                    width: {
                                        size: 70,
                                        type: WidthType.PERCENTAGE,
                                    },
                                }),
                            ],
                        });
                        
                        children.push(
                            new Table({
                                width: {
                                    size: 9071, // 16cm in twips
                                    type: WidthType.DXA,
                                },
                                layout: "fixed",
                                rows: [row],
                            })
                        );
                        
                        children.push(new Paragraph({ spacing: { after: 200 } }));
                    }
                    // Regular format for all other sections (heading + content together)
                    else if (section.content1 || section.content2) {
                        const row = new TableRow({
                            children: [
                                // Left column
                                new TableCell({
                                    children: [
                                        new Paragraph({
                                            children: [
                                                new TextRun({
                                                    text: section.heading1,
                                                    bold: true,
                                                    size: 24, // 12pt
                                                }),
                                            ],
                                            bidirectional: false,
                                        }),
                                        ...section.content1.split('\n').filter(line => line.trim()).map(line => 
                                            new Paragraph({
                                                children: [
                                                    new TextRun({
                                                        text: line.trim().replace(/^[â€¢\-*]\s*/, 'â€¢ '),
                                                        size: 24, // 12pt
                                                    }),
                                                ],
                                                bidirectional: false,
                                            })
                                        ),
                                    ],
                                    width: {
                                        size: 50,
                                        type: WidthType.PERCENTAGE,
                                    },
                                }),
                                // Right column
                                new TableCell({
                                    children: section.content2 ? [
                                        new Paragraph({
                                            children: [
                                                new TextRun({
                                                    text: section.heading2,
                                                    bold: true,
                                                    size: 24, // 12pt
                                                }),
                                            ],
                                            bidirectional: false,
                                        }),
                                        ...section.content2.split('\n').filter(line => line.trim()).map(line => 
                                            new Paragraph({
                                                children: [
                                                    new TextRun({
                                                        text: line.trim().replace(/^[â€¢\-*]\s*/, 'â€¢ '),
                                                        size: 24, // 12pt
                                                    }),
                                                ],
                                                bidirectional: false,
                                            })
                                        ),
                                    ] : [new Paragraph('')],
                                    width: {
                                        size: 50,
                                        type: WidthType.PERCENTAGE,
                                    },
                                }),
                            ],
                        });
                        
                        children.push(
                            new Table({
                                width: {
                                    size: 9071, // 16cm in twips
                                    type: WidthType.DXA,
                                },
                                layout: "fixed",
                                rows: [row],
                            })
                        );
                        
                        children.push(new Paragraph({ spacing: { after: 200 } }));
                    }
                });

                // Add custom sections
                const customSectionsContainer = document.getElementById('customSectionsContainer');
                const customSectionDivs = customSectionsContainer.querySelectorAll('.section-container');
                
                customSectionDivs.forEach(sectionDiv => {
                    const headingElement = sectionDiv.querySelector('h3');
                    const textareaElement = sectionDiv.querySelector('textarea');
                    
                    if (headingElement && textareaElement && textareaElement.value.trim()) {
                        const row = new TableRow({
                            children: [
                                new TableCell({
                                    children: [
                                        new Paragraph({
                                            children: [
                                                new TextRun({
                                                    text: headingElement.textContent,
                                                    bold: true,
                                                    size: 24, // 12pt
                                                }),
                                            ],
                                            bidirectional: false,
                                        }),
                                        ...textareaElement.value.split('\n').filter(line => line.trim()).map(line => 
                                            new Paragraph({
                                                children: [
                                                    new TextRun({
                                                        text: line.trim().replace(/^[â€¢\-*]\s*/, 'â€¢ '),
                                                        size: 24, // 12pt
                                                    }),
                                                ],
                                                bidirectional: false,
                                            })
                                        ),
                                    ],
                                    columnSpan: 2,
                                    width: {
                                        size: 100,
                                        type: WidthType.PERCENTAGE,
                                    },
                                }),
                            ],
                        });
                        
                        children.push(
                            new Table({
                                width: {
                                    size: 9071, // 16cm in twips
                                    type: WidthType.DXA,
                                },
                                layout: "fixed", // Fixed table layout for consistent width
                                rows: [row],
                            })
                        );
                        
                        children.push(new Paragraph({ spacing: { after: 200 } }));
                    }
                });

                // ============ TASK VERIFICATION APPENDIX (if mode = 'appendix') ============
                if (tvExportMode === 'appendix' && collectionMode === 'workshop') {
                    const validResults = Object.keys(workshopResults).filter(key => 
                        workshopResults[key] && workshopResults[key].valid
                    );
                    
                    if (validResults.length > 0) {
                        // Page break before appendix
                        children.push(new Paragraph({
                            children: [new PageBreak()],
                        }));
                        
                        // Appendix title
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: 'Task Verification & Training Priority Analysis (Appendix)',
                                    bold: true,
                                    size: 32, // 16pt
                                }),
                            ],
                            spacing: { after: 300 },
                            bidirectional: false, // Force LTR for Task Verification section
                        }));
                        
                        // Methodology Summary heading
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: 'Methodology Summary',
                                    bold: true,
                                    size: 28, // 14pt
                                }),
                            ],
                            spacing: { after: 200 },
                            bidirectional: false, // Force LTR
                        }));
                        
                        // Methodology details
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: `Data Collection Mode: ${collectionMode === 'workshop' ? 'Workshop (Facilitated)' : 'Individual/Survey'}`,
                                    size: 22,
                                }),
                            ],
                            spacing: { after: 100 },
                            bidirectional: false, // Force LTR
                        }));
                        
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: `Number of Participants: ${workshopParticipants}`,
                                    size: 22,
                                }),
                            ],
                            spacing: { after: 100 },
                            bidirectional: false, // Force LTR
                        }));
                        
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: `Workflow Mode: ${workflowMode === 'standard' ? 'Standard (DACUM)' : 'Extended (DACUM)'}`,
                                    size: 22,
                                }),
                            ],
                            spacing: { after: 100 },
                            bidirectional: false, // Force LTR
                        }));
                        
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: `Priority Formula: ${priorityFormula === 'if' ? 'Importance Ã— Frequency' : 'Importance Ã— Frequency Ã— Difficulty'}`,
                                    size: 22,
                                }),
                            ],
                            spacing: { after: 300 },
                            bidirectional: false, // Force LTR
                        }));
                        
                        // Priority Rankings heading
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: 'Priority Rankings',
                                    bold: true,
                                    size: 28,
                                }),
                            ],
                            spacing: { after: 200 },
                            bidirectional: false, // Force LTR
                        }));
                        
                        // Get and sort results
                        const sortedResults = [];
                        validResults.forEach(taskKey => {
                            const result = workshopResults[taskKey];
                            
                            // Use stored duty and task titles (with backward compatibility)
                            let dutyText = result.dutyTitle;
                            let taskText = result.taskTitle;
                            
                            // Backward compatibility: if not stored, look up from DOM
                            if (!dutyText || !taskText) {
                                const taskParts = taskKey.split('_task_');
                                const dutyId = taskParts[0];
                                
                                if (!dutyText) {
                                    const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                                    dutyText = dutyInput ? dutyInput.value.trim() : 'Unassigned';
                                }
                                
                                if (!taskText) {
                                    const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                                    taskText = taskInput ? taskInput.value.trim() : 'Unassigned';
                                }
                            }
                            
                            sortedResults.push({
                                duty: dutyText,
                                task: taskText,
                                meanI: result.meanImportance,
                                meanF: result.meanFrequency,
                                meanD: result.meanDifficulty,
                                priority: result.priorityIndex
                            });
                        });
                        
                        sortedResults.sort((a, b) => b.priority - a.priority);
                        
                        // Create table
                        const tableRows = [];
                        
                        // Header row
                        tableRows.push(new TableRow({
                            children: [
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Rank', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                                    shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                                }),
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Duty', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                                    shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                                }),
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Task', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                                    shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                                }),
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Mean I', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                                    shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                                }),
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Mean F', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                                    shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                                }),
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Mean D', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                                    shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                                }),
                                new TableCell({
                                    children: [new Paragraph({ children: [new TextRun({ text: 'Priority', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })],
                                    shading: { fill: '667eea', type: ShadingType.SOLID, color: 'ffffff' },
                                }),
                            ],
                        }));
                        
                        // Data rows
                        sortedResults.forEach((row, index) => {
                            tableRows.push(new TableRow({
                                children: [
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: `#${index + 1}` })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ text: row.duty, bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ text: row.task, bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: row.meanI !== null ? row.meanI.toFixed(2) : 'N/A' })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: row.meanF !== null ? row.meanF.toFixed(2) : 'N/A' })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: row.meanD !== null ? row.meanD.toFixed(2) : 'N/A' })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: row.priority !== null ? row.priority.toFixed(2) : 'N/A' })], alignment: AlignmentType.CENTER, bidirectional: false })] }),
                                ],
                            }));
                        });
                        
                        children.push(new Table({
                            width: { size: 100, type: WidthType.PERCENTAGE },
                            rows: tableRows,
                        }));
                        
                        // Duty-Level Summary section
                        children.push(new Paragraph({ spacing: { after: 400 } }));
                        
                        children.push(new Paragraph({
                            children: [new TextRun({ text: 'Duty-Level Summary', bold: true, size: 28 })],
                            spacing: { after: 200 },
                            bidirectional: false,
                        }));
                        
                        children.push(new Paragraph({
                            children: [new TextRun({ text: `Training Load Method: ${trainingLoadMethod === 'advanced' ? 'Advanced (Î£ Priority Ã— Difficulty)' : 'Simple (Avg Priority Ã— Tasks)'}`, size: 20, italics: true })],
                            spacing: { after: 200 },
                            bidirectional: false,
                        }));
                        
                        // Aggregate duty-level data
                        const appendixDutyMap = {};
                        Object.keys(workshopResults).forEach(taskKey => {
                            const result = workshopResults[taskKey];
                            if (result && result.valid) {
                                let dutyId = result.dutyId || taskKey.split('_task_')[0];
                                let dutyTitle = result.dutyTitle;
                                
                                if (!dutyTitle) {
                                    const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                                    dutyTitle = dutyInput ? dutyInput.value.trim() : 'Unassigned';
                                }
                                
                                if (!appendixDutyMap[dutyId]) {
                                    appendixDutyMap[dutyId] = { dutyTitle: dutyTitle, validTasks: 0, prioritySum: 0, tasks: [] };
                                }
                                
                                appendixDutyMap[dutyId].validTasks++;
                                appendixDutyMap[dutyId].prioritySum += result.priorityIndex;
                                appendixDutyMap[dutyId].tasks.push({ priorityIndex: result.priorityIndex, meanDifficulty: result.meanDifficulty });
                            }
                        });
                        
                        const appendixDutyResults = [];
                        Object.keys(appendixDutyMap).forEach(dutyId => {
                            const duty = appendixDutyMap[dutyId];
                            const avgPriority = duty.prioritySum / duty.validTasks;
                            let trainingLoad = 0;
                            if (trainingLoadMethod === 'advanced') {
                                trainingLoad = duty.tasks.reduce((sum, t) => sum + (t.priorityIndex * t.meanDifficulty), 0);
                            } else {
                                trainingLoad = avgPriority * duty.validTasks;
                            }
                            appendixDutyResults.push({ dutyTitle: duty.dutyTitle, validTasks: duty.validTasks, avgPriority: avgPriority, trainingLoad: trainingLoad });
                        });
                        
                        appendixDutyResults.sort((a, b) => b.avgPriority - a.avgPriority);
                        
                        // Duty table
                        const dutyTableRows = [
                            new TableRow({
                                children: [
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: 'Duty Title', bold: true })], alignment: AlignmentType.LEFT, bidirectional: false })], shading: { fill: '667eea' } }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: 'Tasks', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })], shading: { fill: '667eea' } }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: 'Avg Priority', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })], shading: { fill: '667eea' } }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: 'Training Load', bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })], shading: { fill: '667eea' } }),
                                ],
                            })
                        ];
                        
                        appendixDutyResults.forEach(duty => {
                            dutyTableRows.push(new TableRow({
                                children: [
                                    new TableCell({ children: [new Paragraph({ text: duty.dutyTitle, bidirectional: false })], verticalAlign: VerticalAlign.CENTER }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: duty.validTasks.toString() })], alignment: AlignmentType.CENTER, bidirectional: false })], verticalAlign: VerticalAlign.CENTER }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: duty.avgPriority.toFixed(2) })], alignment: AlignmentType.CENTER, bidirectional: false })], verticalAlign: VerticalAlign.CENTER }),
                                    new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: duty.trainingLoad.toFixed(2), bold: true })], alignment: AlignmentType.CENTER, bidirectional: false })], verticalAlign: VerticalAlign.CENTER }),
                                ],
                            }));
                        });
                        
                        children.push(new Table({
                            width: { size: 100, type: WidthType.PERCENTAGE },
                            rows: dutyTableRows,
                        }));
                        
                        // Notes section
                        children.push(new Paragraph({ spacing: { after: 300 } }));
                        
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: 'Notes',
                                    bold: true,
                                    size: 24,
                                }),
                            ],
                            spacing: { after: 200 },
                            bidirectional: false, // Force LTR
                        }));
                        
                        const notes = [
                            'Weighted Mean = Î£(value Ã— count) Ã· total responses',
                            'Priority Index calculated using selected formula',
                            'Higher priority values indicate greater training importance',
                            'Results based on DACUM methodology'
                        ];
                        
                        notes.forEach(note => {
                            children.push(new Paragraph({
                                children: [
                                    new TextRun({
                                        text: `â€¢ ${note}`,
                                        size: 20,
                                    }),
                                ],
                                spacing: { after: 100 },
                                bidirectional: false, // Force LTR
                            }));
                        });
                    }
                }

                // ============ VERIFIED LIVE WORKSHOP RESULTS APPENDIX ============
                if (tvExportMode === 'appendix' && hasVerifiedResults) {
                    // Page break before verified results appendix
                    children.push(new Paragraph({ children: [new PageBreak()] }));
                    
                    // Appendix title
                    children.push(new Paragraph({
                        children: [
                            new TextRun({
                                text: 'DACUM Live Pro - Verified (Post-Vote) Results (Appendix)',
                                bold: true,
                                size: 32,
                            }),
                        ],
                        spacing: { after: 300 },
                        bidirectional: false,
                    }));
                    
                    // Metadata
                    children.push(new Paragraph({
                        children: [new TextRun({ text: `Occupation: ${lwFinalizedData.occupation}`, size: 22 })],
                        spacing: { after: 100 },
                        bidirectional: false,
                    }));
                    children.push(new Paragraph({
                        children: [new TextRun({ text: `Job Title: ${lwFinalizedData.jobTitle}`, size: 22 })],
                        spacing: { after: 100 },
                        bidirectional: false,
                    }));
                    children.push(new Paragraph({
                        children: [new TextRun({ text: `Date: ${new Date().toLocaleDateString()}`, size: 22 })],
                        spacing: { after: 100 },
                        bidirectional: false,
                    }));
                    const vFormula = lwFinalizedData.priorityFormula || 'if';
                    const vFormulaText = vFormula === 'ifd' ? 'Importance Ã— Frequency Ã— Difficulty' : 'Importance Ã— Frequency';
                    children.push(new Paragraph({
                        children: [new TextRun({ text: `Priority Formula: ${vFormulaText}`, size: 22 })],
                        spacing: { after: 100 },
                        bidirectional: false,
                    }));
                    children.push(new Paragraph({
                        children: [new TextRun({ text: `Total Participants: ${lwAggregatedResults.totalVotes}`, size: 22 })],
                        spacing: { after: 300 },
                        bidirectional: false,
                    }));
                    
                    // Collect all verified tasks with metrics
                    const verifiedTasks = [];
                    Object.keys(lwFinalizedData.duties).forEach(dutyId => {
                        const duty = lwFinalizedData.duties[dutyId];
                        duty.tasks.forEach(task => {
                            if (task.priorityIndex !== undefined) {
                                verifiedTasks.push({
                                    dutyTitle: duty.title,
                                    taskText: task.text,
                                    meanImportance: task.meanImportance,
                                    meanFrequency: task.meanFrequency,
                                    meanDifficulty: task.meanDifficulty,
                                    priorityIndex: task.priorityIndex,
                                    rank: task.rank
                                });
                            }
                        });
                    });
                    
                    verifiedTasks.sort((a, b) => a.rank - b.rank);
                    
                    // Create table
                    const verifiedTableRows = [
                        new TableRow({
                            children: [
                                new TableCell({ children: [new Paragraph({ text: 'Rank', bold: true, bidirectional: false })], width: { size: 8, type: WidthType.PERCENTAGE } }),
                                new TableCell({ children: [new Paragraph({ text: 'Duty', bold: true, bidirectional: false })], width: { size: 22, type: WidthType.PERCENTAGE } }),
                                new TableCell({ children: [new Paragraph({ text: 'Task', bold: true, bidirectional: false })], width: { size: 35, type: WidthType.PERCENTAGE } }),
                                new TableCell({ children: [new Paragraph({ text: 'I', bold: true, bidirectional: false })], width: { size: 8, type: WidthType.PERCENTAGE } }),
                                new TableCell({ children: [new Paragraph({ text: 'F', bold: true, bidirectional: false })], width: { size: 8, type: WidthType.PERCENTAGE } }),
                                new TableCell({ children: [new Paragraph({ text: 'D', bold: true, bidirectional: false })], width: { size: 8, type: WidthType.PERCENTAGE } }),
                                new TableCell({ children: [new Paragraph({ text: 'PI', bold: true, bidirectional: false })], width: { size: 11, type: WidthType.PERCENTAGE } })
                            ]
                        })
                    ];
                    
                    verifiedTasks.forEach(task => {
                        verifiedTableRows.push(
                            new TableRow({
                                children: [
                                    new TableCell({ children: [new Paragraph({ text: String(task.rank), bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ text: task.dutyTitle, bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ text: task.taskText, bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ text: task.meanImportance.toFixed(2), bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ text: task.meanFrequency.toFixed(2), bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ text: task.meanDifficulty.toFixed(2), bidirectional: false })] }),
                                    new TableCell({ children: [new Paragraph({ text: task.priorityIndex.toFixed(2), bidirectional: false })] })
                                ]
                            })
                        );
                    });
                    
                    children.push(new Table({
                        rows: verifiedTableRows,
                        width: { size: 100, type: WidthType.PERCENTAGE }
                    }));
                }

                // ============ COMPETENCY CLUSTERS SECTION ============
                if (clusteringData.clusters && clusteringData.clusters.length > 0) {
                    children.push(new Paragraph({ children: [new PageBreak()], bidirectional: false }));
                    
                    children.push(new Paragraph({
                        children: [
                            new TextRun({
                                text: 'Competency Clusters',
                                bold: true,
                                size: 32, // 16pt
                            }),
                        ],
                        spacing: { before: 400, after: 400 },
                        alignment: AlignmentType.CENTER,
                        bidirectional: false,
                    }));
                    
                    clusteringData.clusters.forEach(cluster => {
                        // Cluster header
                        children.push(new Paragraph({
                            children: [
                                new TextRun({
                                    text: cluster.name,
                                    bold: true,
                                    size: 28, // 14pt
                                }),
                            ],
                            spacing: { before: 300, after: 200 },
                            bidirectional: false,
                        }));
                        
                        // Cluster tasks
                        cluster.tasks.forEach((task, index) => {
                            const taskCode = getTaskCode(task.id);
                            children.push(new Paragraph({
                                children: [
                                    new TextRun({
                                        text: `${index + 1}. ${taskCode}: ${task.text}`,
                                        size: 22, // 11pt
                                    }),
                                ],
                                spacing: { after: 100 },
                                indent: { left: 720 },
                                bidirectional: false,
                            }));
                        });
                    });
                }

                // Create document
                const doc = new Document({
                    sections: [{
                        properties: {
                            page: {
                                margin: {
                                    top: 1440,
                                    right: 1440,
                                    bottom: 1440,
                                    left: 1440,
                                },
                            },
                        },
                        children: children,
                    }],
                });

                // Generate and download
                const blob = await Packer.toBlob(doc);
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${occupationTitle.replace(/[^a-z0-9]/gi, '_')}_${jobTitle.replace(/[^a-z0-9]/gi, '_')}_DACUM_Chart.docx`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showStatus('Word document exported successfully! âœ“', 'success');

            } catch (error) {
                console.error('Error generating Word document:', error);
                showStatus('Error generating Word document: ' + error.message, 'error');
            }
        }

        async function generateAIDacum() {
            console.log('ğŸš€ AI Generation Started');
            
            // Check usage limit FIRST
            const usageStatus = checkUsageLimit();
            if (!usageStatus.allowed) {
                showStatus(`âŒ Daily limit reached (${DAILY_LIMIT} generations). Try again tomorrow!`, 'error');
                return;
            }
            
            const occupationTitle = document.getElementById('occupationTitle').value.trim();
            const jobTitle = document.getElementById('jobTitle').value.trim();
            const sector = document.getElementById('sector').value.trim();
            const context = document.getElementById('context').value.trim();

            console.log('Input values:', { occupationTitle, jobTitle, sector, context });

            if (!occupationTitle || !jobTitle) {
                console.log('âŒ Validation failed - missing required fields');
                showStatus('Please enter both Occupation Title and Job Title before generating AI draft', 'error');
                return;
            }

            console.log('âœ… Validation passed');

            // Check if there are existing duties with actual content
            const existingDuties = document.querySelectorAll('[data-duty-id]');
            let hasContent = false;
            
            existingDuties.forEach(dutyInput => {
                if (dutyInput.value.trim()) {
                    hasContent = true;
                }
            });

            if (hasContent) {
                console.log(`Found ${existingDuties.length} existing duties with content`);
                if (!confirm('âš ï¸ AI GENERATION WILL REPLACE ALL EXISTING DUTIES AND TASKS\n\nClick OK to continue, or Cancel to keep your current work.')) {
                    console.log('User cancelled - keeping existing duties');
                    showStatus('AI generation cancelled. Your existing duties are preserved.', 'error');
                    return;
                }
                console.log('âœ… User confirmed - proceeding with AI generation');
            } else {
                console.log('No existing content found - proceeding without confirmation');
            }

            console.log('ğŸ¯ Starting AI API call...');
            showLoadingModal(); // Show loading popup

            const prompt = `You are an occupational analysis engine. Your task is to generate a DATA-INFORMED DACUM DRAFT that will be injected directly into a DACUM chart user interface.

INPUT:
Occupation Title: ${occupationTitle}
Job / Role: ${jobTitle}${sector ? `\nSector: ${sector}` : ''}${context ? `\nCountry / Context: ${context}` : ''}

TASK:
Generate a draft DACUM structure as follows:
- Create between 6 and 8 DUTIES.
- For each DUTY, create between 5 and 8 TASKS.

RULES FOR DUTIES:
- Duties represent broad areas of responsibility.
- Duties must be written as responsibility titles (e.g., "Apply Safety, Health, Environment and Quality in the Workplace").
- Avoid overlap between duties.

RULES FOR TASKS:
- Each task must start with ONE clear occupational action verb.
- Use operational verbs only (e.g. Install, Inspect, Maintain, Test, Repair, Calibrate, Diagnose, Configure).
- Tasks must describe real, observable work activities.
- Do NOT use learning, academic, or cognitive verbs (like "understand", "learn", "know").
- Do NOT include competencies, skills, knowledge, tools, or safety rules.
- Tasks must be specific and actionable.

OUTPUT FORMAT (STRICT â€“ NO EXTRA TEXT):
Return ONLY valid JSON using the following structure:

{
  "duties": [
    {
      "title": "Duty title here",
      "tasks": [
        "Task 1",
        "Task 2",
        "Task 3",
        "Task 4",
        "Task 5"
      ]
    }
  ]
}

Generate the DACUM draft now in valid JSON format only.`;

            try {
                // Call YOUR backend server on Railway (not Anthropic API directly)
                const BACKEND_URL = 'https://dacum-ai-backend-production.up.railway.app';
                
                console.log(`ğŸŒ Calling backend server: ${BACKEND_URL}`);
                
                const response = await fetch(`${BACKEND_URL}/api/generate-dacum`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        prompt: prompt
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Backend Error Response:', errorText);
                    throw new Error(`Backend request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Backend Response:', data);
                
                if (!data.content || !data.content[0] || !data.content[0].text) {
                    console.error('Invalid response structure:', data);
                    throw new Error('Invalid response from backend - no content found');
                }

                let jsonText = data.content[0].text.trim();
                console.log('Raw AI text:', jsonText);
                
                // Remove markdown code blocks if present
                jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                
                let dacumData;
                try {
                    dacumData = JSON.parse(jsonText);
                } catch (parseError) {
                    console.error('JSON Parse Error:', parseError);
                    console.error('Failed to parse:', jsonText);
                    throw new Error('Failed to parse AI response as JSON');
                }

                if (!dacumData.duties || !Array.isArray(dacumData.duties)) {
                    console.error('Invalid DACUM structure:', dacumData);
                    throw new Error('Invalid DACUM structure - duties array not found');
                }

                if (dacumData.duties.length === 0) {
                    throw new Error('No duties generated by AI');
                }

                // Clear existing duties
                document.getElementById('dutiesContainer').innerHTML = '';
                dutyCount = 0;
                taskCounts = {};

                // Populate with AI-generated data
                dacumData.duties.forEach((dutyData, index) => {
                    addDuty();
                    const currentDutyId = `duty_${dutyCount}`;
                    const dutyInput = document.querySelector(`[data-duty-id="${currentDutyId}"]`);
                    
                    if (dutyInput && dutyData.title) {
                        dutyInput.value = dutyData.title;
                    }

                    if (dutyData.tasks && Array.isArray(dutyData.tasks)) {
                        dutyData.tasks.forEach(taskText => {
                            addTask(currentDutyId);
                            const taskInputs = document.querySelectorAll(`[data-task-id^="${currentDutyId}_"]`);
                            const lastTaskInput = taskInputs[taskInputs.length - 1];
                            if (lastTaskInput) {
                                lastTaskInput.value = taskText;
                            }
                        });
                    }
                });

                // Hide loading modal and increment usage counter
                hideLoadingModal();
                incrementUsage();
                
                // User is already in Duties & Tasks tab - no need to switch
                showStatus(`âœ“ AI draft generated successfully! ${dacumData.duties.length} duties with tasks created.`, 'success');

            } catch (error) {
                hideLoadingModal(); // Hide modal on error too
                console.error('Error generating AI DACUM:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack
                });
                showStatus(`Error: ${error.message}. Check browser console for details.`, 'error');
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

// PDF Export (original functionality preserved)
document.addEventListener('DOMContentLoaded', function() {
    const exportButton = document.querySelector('.btn-export');
    
    exportButton.addEventListener('click', exportToPDF);
});

// ============ STANDALONE TASK VERIFICATION PDF EXPORT ============
function exportTaskVerificationPDF() {
    try {
        // Check if we have Task Verification data
        if (collectionMode !== 'workshop' || !workshopResults || Object.keys(workshopResults).length === 0) {
            alert('No Task Verification data available. Please complete workshop counts in the Task Verification tab first.');
            return;
        }
        
        const validResults = Object.keys(workshopResults).filter(key => 
            workshopResults[key] && workshopResults[key].valid
        );
        
        if (validResults.length === 0) {
            alert('No valid Task Verification results. Please ensure all required fields are completed.');
            return;
        }
        
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: 'landscape',
            unit: 'mm',
            format: 'a4'
        });
        
        const margin = 10;
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        let yPos = margin + 10;
        
        // Get occupation title
        const occupationTitleInput = document.getElementById('occupationTitle');
        const occupationTitle = occupationTitleInput ? occupationTitleInput.value : 'Unknown Occupation';
        
        // Title Page
        pdf.setFontSize(18);
        pdf.setFont(undefined, 'bold');
        pdf.text('Task Verification & Training Priority Analysis', pageWidth / 2, yPos, { align: 'center' });
        yPos += 12;
        
        pdf.setFontSize(14);
        pdf.setFont(undefined, 'bold');
        pdf.text(`Occupation: ${occupationTitle}`, pageWidth / 2, yPos, { align: 'center' });
        yPos += 10;
        
        pdf.setFontSize(12);
        pdf.setFont(undefined, 'normal');
        const today = new Date().toLocaleDateString();
        pdf.text(`Date of Analysis: ${today}`, pageWidth / 2, yPos, { align: 'center' });
        yPos += 8;
        
        pdf.setFontSize(10);
        pdf.setFont(undefined, 'italic');
        pdf.text(`This Task Verification is based on the DACUM Chart for ${occupationTitle}.`, pageWidth / 2, yPos, { align: 'center' });
        yPos += 15;
        
        // Methodology Summary
        pdf.setFontSize(14);
        pdf.setFont(undefined, 'bold');
        pdf.text('Methodology Summary', margin, yPos);
        yPos += 8;
        
        pdf.setFontSize(11);
        pdf.setFont(undefined, 'normal');
        pdf.text(`Data Collection Mode: ${collectionMode === 'workshop' ? 'Workshop (Facilitated)' : 'Individual/Survey'}`, margin, yPos);
        yPos += 6;
        pdf.text(`Number of Participants: ${workshopParticipants}`, margin, yPos);
        yPos += 6;
        pdf.text(`Workflow Mode: ${workflowMode === 'standard' ? 'Standard (DACUM)' : 'Extended (DACUM)'}`, margin, yPos);
        yPos += 6;
        pdf.text(`Priority Formula: ${priorityFormula === 'if' ? 'Importance Ã— Frequency' : 'Importance Ã— Frequency Ã— Difficulty'}`, margin, yPos);
        yPos += 12;
        
        // Priority Rankings Table
        pdf.setFontSize(14);
        pdf.setFont(undefined, 'bold');
        pdf.text('Priority Rankings', margin, yPos);
        yPos += 8;
        
        // Get and sort results
        const sortedResults = [];
        validResults.forEach(taskKey => {
            const result = workshopResults[taskKey];
            
            // Use stored duty and task titles (with backward compatibility)
            let dutyText = result.dutyTitle;
            let taskText = result.taskTitle;
            
            // Backward compatibility: if not stored, look up from DOM
            if (!dutyText || !taskText) {
                const taskParts = taskKey.split('_task_');
                const dutyId = taskParts[0];
                
                if (!dutyText) {
                    const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                    dutyText = dutyInput ? dutyInput.value.trim() : 'Unassigned';
                }
                
                if (!taskText) {
                    const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                    taskText = taskInput ? taskInput.value.trim() : 'Unassigned';
                }
            }
            
            sortedResults.push({
                duty: dutyText,
                task: taskText,
                meanI: result.meanImportance,
                meanF: result.meanFrequency,
                meanD: result.meanDifficulty,
                priority: result.priorityIndex
            });
        });
        
        sortedResults.sort((a, b) => b.priority - a.priority);
        
        // Table headers
        const colWidths = [15, 50, 75, 25, 25, 25, 25];
        const headers = ['Rank', 'Duty', 'Task', 'Mean I', 'Mean F', 'Mean D', 'Priority'];
        
        pdf.setFontSize(10);
        pdf.setFont(undefined, 'bold');
        let xPos = margin;
        headers.forEach((header, i) => {
            pdf.text(header, xPos, yPos);
            xPos += colWidths[i];
        });
        yPos += 6;
        
        // Table rows
        pdf.setFont(undefined, 'normal');
        sortedResults.forEach((row, index) => {
            if (yPos > pageHeight - 20) {
                pdf.addPage();
                yPos = margin + 10;
            }
            
            xPos = margin;
            pdf.text(`#${index + 1}`, xPos, yPos);
            xPos += colWidths[0];
            
            const dutyTrunc = row.duty.length > 20 ? row.duty.substring(0, 17) + '...' : row.duty;
            pdf.text(dutyTrunc, xPos, yPos);
            xPos += colWidths[1];
            
            const taskTrunc = row.task.length > 40 ? row.task.substring(0, 37) + '...' : row.task;
            pdf.text(taskTrunc, xPos, yPos);
            xPos += colWidths[2];
            
            pdf.text(row.meanI !== null ? row.meanI.toFixed(2) : 'N/A', xPos, yPos);
            xPos += colWidths[3];
            pdf.text(row.meanF !== null ? row.meanF.toFixed(2) : 'N/A', xPos, yPos);
            xPos += colWidths[4];
            pdf.text(row.meanD !== null ? row.meanD.toFixed(2) : 'N/A', xPos, yPos);
            xPos += colWidths[5];
            pdf.text(row.priority !== null ? row.priority.toFixed(2) : 'N/A', xPos, yPos);
            
            yPos += 5;
        });
        
        yPos += 10;
        
        // Duty-Level Summary Section
        if (yPos > pageHeight - 30) {
            pdf.addPage();
            yPos = margin + 10;
        }
        
        pdf.setFontSize(14);
        pdf.setFont(undefined, 'bold');
        pdf.text('Duty-Level Summary', margin, yPos);
        yPos += 5;
        
        pdf.setFontSize(9);
        pdf.setFont(undefined, 'italic');
        pdf.text(`Training Load Method: ${trainingLoadMethod === 'advanced' ? 'Advanced (Î£ Priority Ã— Difficulty)' : 'Simple (Avg Priority Ã— Tasks)'}`, margin, yPos);
        yPos += 8;
        
        // Aggregate duty-level data
        const dutyMap = {};
        Object.keys(workshopResults).forEach(taskKey => {
            const result = workshopResults[taskKey];
            if (result && result.valid) {
                let dutyId = result.dutyId || taskKey.split('_task_')[0];
                let dutyTitle = result.dutyTitle;
                
                if (!dutyTitle) {
                    const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                    dutyTitle = dutyInput ? dutyInput.value.trim() : 'Unassigned';
                }
                
                if (!dutyMap[dutyId]) {
                    dutyMap[dutyId] = {
                        dutyTitle: dutyTitle,
                        validTasks: 0,
                        prioritySum: 0,
                        difficultySum: 0,
                        tasks: []
                    };
                }
                
                dutyMap[dutyId].validTasks++;
                dutyMap[dutyId].prioritySum += result.priorityIndex;
                dutyMap[dutyId].difficultySum += result.meanDifficulty;
                dutyMap[dutyId].tasks.push({
                    priorityIndex: result.priorityIndex,
                    meanDifficulty: result.meanDifficulty
                });
            }
        });
        
        const dutyResults = [];
        Object.keys(dutyMap).forEach(dutyId => {
            const duty = dutyMap[dutyId];
            const avgPriority = duty.prioritySum / duty.validTasks;
            
            let trainingLoad = 0;
            if (trainingLoadMethod === 'advanced') {
                trainingLoad = duty.tasks.reduce((sum, t) => sum + (t.priorityIndex * t.meanDifficulty), 0);
            } else {
                trainingLoad = avgPriority * duty.validTasks;
            }
            
            dutyResults.push({
                dutyTitle: duty.dutyTitle,
                validTasks: duty.validTasks,
                avgPriority: avgPriority,
                trainingLoad: trainingLoad
            });
        });
        
        dutyResults.sort((a, b) => b.avgPriority - a.avgPriority);
        
        // Duty table headers
        const dutyColWidths = [80, 30, 40, 45];
        const dutyHeaders = ['Duty Title', 'Tasks', 'Avg Priority', 'Training Load'];
        
        pdf.setFontSize(9);
        pdf.setFont(undefined, 'bold');
        let dutyXPos = margin;
        dutyHeaders.forEach((header, i) => {
            pdf.text(header, dutyXPos, yPos);
            dutyXPos += dutyColWidths[i];
        });
        yPos += 6;
        
        // Duty table rows
        pdf.setFont(undefined, 'normal');
        dutyResults.forEach((duty) => {
            if (yPos > pageHeight - 20) {
                pdf.addPage();
                yPos = margin + 10;
            }
            
            dutyXPos = margin;
            const dutyTitleTrunc = duty.dutyTitle.length > 35 ? duty.dutyTitle.substring(0, 32) + '...' : duty.dutyTitle;
            pdf.text(dutyTitleTrunc, dutyXPos, yPos);
            dutyXPos += dutyColWidths[0];
            
            pdf.text(duty.validTasks.toString(), dutyXPos, yPos);
            dutyXPos += dutyColWidths[1];
            
            pdf.text(duty.avgPriority.toFixed(2), dutyXPos, yPos);
            dutyXPos += dutyColWidths[2];
            
            pdf.text(duty.trainingLoad.toFixed(2), dutyXPos, yPos);
            
            yPos += 5;
        });
        
        yPos += 10;
        
        // Notes section
        pdf.setFontSize(12);
        pdf.setFont(undefined, 'bold');
        pdf.text('Notes & Methodology', margin, yPos);
        yPos += 7;
        
        pdf.setFontSize(10);
        pdf.setFont(undefined, 'normal');
        const notes = [
            'Weighted Mean = Î£(value Ã— count) Ã· total responses',
            'Importance scale: 0=Not Important, 1=Somewhat, 2=Important, 3=Critical',
            'Frequency scale: 0=Rarely, 1=Sometimes, 2=Often, 3=Daily',
            'Difficulty scale: 0=Easy, 1=Moderate, 2=Challenging, 3=Very Difficult',
            `Priority Index = ${priorityFormula === 'if' ? 'Mean Importance Ã— Mean Frequency' : 'Mean Importance Ã— Mean Frequency Ã— Mean Difficulty'}`,
            'Higher priority values indicate greater training importance',
            'Results follow DACUM (Developing A Curriculum) methodology'
        ];
        
        notes.forEach(note => {
            if (yPos > pageHeight - 15) {
                pdf.addPage();
                yPos = margin + 10;
            }
            pdf.text(`â€¢ ${note}`, margin, yPos);
            yPos += 5;
        });
        
        // Save PDF
        pdf.save(`${occupationTitle.replace(/[^a-z0-9]/gi, '_')}_Task_Verification.pdf`);
        showStatus('Task Verification PDF exported successfully! âœ“', 'success');
        
    } catch (error) {
        console.error('Error generating Task Verification PDF:', error);
        showStatus('Error generating Task Verification PDF: ' + error.message, 'error');
    }
}

function exportToPDF() {
    // ============ CHECK FOR VERIFIED LIVE WORKSHOP RESULTS ============
    const hasVerifiedResults = typeof lwFinalizedData !== 'undefined' && lwFinalizedData && 
                                typeof lwAggregatedResults !== 'undefined' && lwAggregatedResults;
    
    // ============ VERIFIED LIVE WORKSHOP STANDALONE EXPORT ============
    if (hasVerifiedResults && tvExportMode === 'standalone') {
        lwExportVerifiedPDF();
        return;
    }
    
    // ============ REGULAR TASK VERIFICATION STANDALONE EXPORT ============
    if (!hasVerifiedResults && tvExportMode === 'standalone') {
        exportTaskVerificationPDF();
        return;
    }
    
    // ============ NORMAL DACUM EXPORT (with optional appendix) ============
    try {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: 'landscape',
            unit: 'mm',
            format: 'a4'
        });
        
        // Get input values
        const dacumDateInput = document.getElementById('dacumDate');
        let dacumDateFormatted = '';
        if (dacumDateInput.value) {
            const dateObj = new Date(dacumDateInput.value + 'T00:00:00');
            const month = String(dateObj.getMonth() + 1).padStart(2, '0');
            const day = String(dateObj.getDate()).padStart(2, '0');
            const year = dateObj.getFullYear();
            dacumDateFormatted = `${month}-${day}-${year}`;
        }
        const producedForInput = document.getElementById('producedFor');
        const producedByInput = document.getElementById('producedBy');
        const occupationTitleInput = document.getElementById('occupationTitle');
        const jobTitleInput = document.getElementById('jobTitle');
        const toolsInput = document.getElementById('toolsInput');
        const trendsInput = document.getElementById('trendsInput');
        const acronymsInput = document.getElementById('acronymsInput');
        
        // Validation
        if (!occupationTitleInput.value || !jobTitleInput.value) {
            alert('Please fill in at least the Occupation Title and Job Title');
            return;
        }
        
        const margin = 10;
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        let yPos = margin + 10;
        
        // ============ TITLE PAGE ============
        pdf.setFontSize(18); // 18pt for main title
        pdf.setFont(undefined, 'bold');
        pdf.text(`DACUM Research Chart for ${occupationTitleInput.value}`, pageWidth / 2, yPos, { align: 'center' });
        yPos += 15;
        
        // Two column layout for title page
        const leftColX = margin + 10;
        const rightColX = pageWidth / 2 + 10;
        let leftY = yPos;
        let rightY = yPos;
        
        // Left column - Produced For/By
        if (producedForInput.value) {
            pdf.setFontSize(16); // 16pt for labels
            pdf.setFont(undefined, 'bold');
            pdf.text('Produced for', leftColX, leftY);
            leftY += 7;
            
            // Add logo if exists
            if (producedForImage) {
                try {
                    const imgWidth = 30;
                    const imgHeight = 20;
                    pdf.addImage(producedForImage, 'JPEG', leftColX, leftY, imgWidth, imgHeight);
                    leftY += imgHeight + 5;
                } catch (e) {
                    console.error('Error adding Produced For image:', e);
                }
            }
            
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(14); // 14pt for content
            pdf.text(producedForInput.value, leftColX, leftY);
            leftY += 15;
        }
        
        if (producedByInput.value) {
            pdf.setFontSize(16); // 16pt for labels
            pdf.setFont(undefined, 'bold');
            pdf.text('Produced by', leftColX, leftY);
            leftY += 7;
            
            // Add logo if exists
            if (producedByImage) {
                try {
                    const imgWidth = 30;
                    const imgHeight = 20;
                    pdf.addImage(producedByImage, 'JPEG', leftColX, leftY, imgWidth, imgHeight);
                    leftY += imgHeight + 5;
                } catch (e) {
                    console.error('Error adding Produced By image:', e);
                }
            }
            
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(14); // 14pt for content
            pdf.text(producedByInput.value, leftColX, leftY);
            leftY += 10;
        }
        
        if (dacumDateFormatted) {
            pdf.setFontSize(14); // 14pt for date
            pdf.setFont(undefined, 'bold');
            pdf.text(dacumDateFormatted, leftColX, leftY);
        }
        
        // Right column - Job info
        pdf.setFontSize(16); // 16pt for labels
        pdf.setFont(undefined, 'bold');
        pdf.text('Occupation:', rightColX, rightY);
        pdf.setFont(undefined, 'normal');
        pdf.setFontSize(14); // 14pt for content
        pdf.text(jobTitleInput.value, rightColX + 30, rightY);
        rightY += 7;
        
        pdf.setFontSize(16); // 16pt for labels
        pdf.setFont(undefined, 'bold');
        pdf.text('Job:', rightColX, rightY);
        pdf.setFont(undefined, 'normal');
        pdf.setFontSize(14); // 14pt for content
        pdf.text(occupationTitleInput.value, rightColX + 15, rightY);
        
        // ============ DACUM CHART GRID ============
        pdf.addPage('a4', 'landscape');
        yPos = margin + 5;
        
        // Collect duties and tasks
        const dutyInputs = document.querySelectorAll('[data-duty-id]');
        const duties = [];
        
        dutyInputs.forEach(dutyInput => {
            const dutyText = dutyInput.value.trim();
            if (dutyText) {
                const dutyId = dutyInput.getAttribute('data-duty-id');
                const taskInputs = document.querySelectorAll(`[data-task-id^="${dutyId}_"]`);
                const tasks = [];
                
                taskInputs.forEach(taskInput => {
                    const taskText = taskInput.value.trim();
                    if (taskText) {
                        tasks.push(taskText);
                    }
                });
                
                duties.push({
                    duty: dutyText,
                    tasks: tasks
                });
            }
        });
        
        if (duties.length === 0) {
            showStatus('Please add at least one duty with tasks', 'error');
            return;
        }
        
        // DUTIES AND TASKS header
        pdf.setFillColor(200, 200, 200);
        pdf.rect(margin, yPos, pageWidth - (margin * 2), 8, 'FD');
        pdf.setFontSize(14); // 14pt for heading
        pdf.setFont(undefined, 'bold');
        pdf.text('DUTIES AND TASKS', pageWidth / 2, yPos + 5.5, { align: 'center' });
        yPos += 8;
        
        // Calculate columns (max 4 duties per row)
        const maxCols = 4;
        const chartWidth = pageWidth - (margin * 2);
        const colWidth = chartWidth / maxCols;
        
        let dutyIndex = 0;
        
        while (dutyIndex < duties.length) {
            const dutiesThisRow = Math.min(maxCols, duties.length - dutyIndex);
            
            // Draw duty headers
            let maxHeaderHeight = 10;
            pdf.setFillColor(220, 220, 220);
            
            for (let col = 0; col < dutiesThisRow; col++) {
                const duty = duties[dutyIndex + col];
                const x = margin + (col * colWidth);
                const letter = String.fromCharCode(65 + dutyIndex + col);
                
                pdf.rect(x, yPos, colWidth, 10, 'S');
                pdf.setFontSize(14); // 14pt for duty headers
                pdf.setFont(undefined, 'bold');
                
                const headerText = `DUTY ${letter}: ${duty.duty}`;
                const lines = pdf.splitTextToSize(headerText, colWidth - 3);
                const textHeight = lines.length * 4.5 + 3; // Adjusted for larger font
                maxHeaderHeight = Math.max(maxHeaderHeight, textHeight);
            }
            
            // Redraw with correct height
            for (let col = 0; col < dutiesThisRow; col++) {
                const duty = duties[dutyIndex + col];
                const x = margin + (col * colWidth);
                const letter = String.fromCharCode(65 + dutyIndex + col);
                
                pdf.setFillColor(220, 220, 220);
                pdf.rect(x, yPos, colWidth, maxHeaderHeight, 'FD');
                
                pdf.setFontSize(14); // 14pt for duty headers
                const headerText = `DUTY ${letter}: ${duty.duty}`;
                const lines = pdf.splitTextToSize(headerText, colWidth - 3);
                pdf.text(lines, x + 1.5, yPos + 4.5);
            }
            
            yPos += maxHeaderHeight;
            
            // Draw tasks
            const maxTasks = Math.max(...duties.slice(dutyIndex, dutyIndex + dutiesThisRow).map(d => d.tasks.length));
            
            for (let taskRow = 0; taskRow < maxTasks; taskRow++) {
                let rowHeight = 15;
                
                // Calculate row height
                for (let col = 0; col < dutiesThisRow; col++) {
                    const duty = duties[dutyIndex + col];
                    if (duty.tasks[taskRow]) {
                        pdf.setFontSize(12); // 12pt for task text
                        const letter = String.fromCharCode(65 + dutyIndex + col);
                        const taskText = `Task ${letter}${taskRow + 1}:\n${duty.tasks[taskRow]}`;
                        const lines = pdf.splitTextToSize(taskText, colWidth - 3);
                        const textHeight = lines.length * 4 + 3; // Adjusted for larger font
                        rowHeight = Math.max(rowHeight, textHeight);
                    }
                }
                
                // Check page break
                if (yPos + rowHeight > pageHeight - margin - 5) {
                    pdf.addPage('a4', 'landscape');
                    yPos = margin + 5;
                    
                    // Repeat header
                    pdf.setFillColor(200, 200, 200);
                    pdf.rect(margin, yPos, pageWidth - (margin * 2), 8, 'FD');
                    pdf.setFontSize(14); // 14pt for heading
                    pdf.setFont(undefined, 'bold');
                    pdf.text('DUTIES AND TASKS (continued)', pageWidth / 2, yPos + 5.5, { align: 'center' });
                    yPos += 8;
                }
                
                // Draw task cells
                pdf.setFont(undefined, 'normal');
                pdf.setFontSize(12); // 12pt for task text
                
                for (let col = 0; col < dutiesThisRow; col++) {
                    const duty = duties[dutyIndex + col];
                    const x = margin + (col * colWidth);
                    
                    pdf.rect(x, yPos, colWidth, rowHeight, 'S');
                    
                    if (duty.tasks[taskRow]) {
                        const letter = String.fromCharCode(65 + dutyIndex + col);
                        const taskText = `Task ${letter}${taskRow + 1}:\n${duty.tasks[taskRow]}`;
                        const lines = pdf.splitTextToSize(taskText, colWidth - 3);
                        pdf.text(lines, x + 1.5, yPos + 3);
                    }
                }
                
                yPos += rowHeight;
            }
            
            dutyIndex += dutiesThisRow;
            
            if (dutyIndex < duties.length) {
                pdf.addPage('a4', 'landscape');
                yPos = margin + 5;
                
                pdf.setFillColor(200, 200, 200);
                pdf.rect(margin, yPos, pageWidth - (margin * 2), 8, 'FD');
                pdf.setFontSize(14); // 14pt for heading
                pdf.setFont(undefined, 'bold');
                pdf.text('DUTIES AND TASKS (continued)', pageWidth / 2, yPos + 5.5, { align: 'center' });
                yPos += 8;
            }
        }
        
        // ============ KNOWLEDGE, SKILLS, BEHAVIORS ============
        const knowledgeText = document.getElementById('knowledgeInput').value.trim();
        const skillsText = document.getElementById('skillsInput').value.trim();
        const behaviorsText = document.getElementById('behaviorsInput').value.trim();
        
        if (knowledgeText || skillsText || behaviorsText) {
            pdf.addPage('a4', 'landscape');
            yPos = margin + 5;
            
            pdf.setFontSize(14); // 14pt for main heading
            pdf.setFont(undefined, 'bold');
            pdf.text('General Knowledge and Skills', pageWidth / 2, yPos, { align: 'center' });
            yPos += 8;
            
            const thirdWidth = (pageWidth - (margin * 2)) / 3;
            let col1Y = yPos;
            let col2Y = yPos;
            let col3Y = yPos;
            
            if (knowledgeText) {
                const heading = document.getElementById('knowledgeHeading').textContent;
                pdf.setFontSize(14); // 14pt for section heading
                pdf.setFont(undefined, 'bold');
                pdf.text(heading, margin, col1Y);
                col1Y += 6;
                
                pdf.setFontSize(12); // 12pt for content
                pdf.setFont(undefined, 'normal');
                const items = knowledgeText.split('\n').filter(line => line.trim());
                items.forEach(item => {
                    const clean = item.trim().replace(/^[â€¢\-*]\s*/, '');
                    pdf.text(clean, margin, col1Y);
                    col1Y += 4.5;
                });
            }
            
            if (skillsText) {
                const heading = document.getElementById('skillsHeading').textContent;
                pdf.setFontSize(14); // 14pt for section heading
                pdf.setFont(undefined, 'bold');
                pdf.text(heading, margin + thirdWidth, col2Y);
                col2Y += 6;
                
                pdf.setFontSize(12); // 12pt for content
                pdf.setFont(undefined, 'normal');
                const items = skillsText.split('\n').filter(line => line.trim());
                items.forEach(item => {
                    const clean = item.trim().replace(/^[â€¢\-*]\s*/, '');
                    pdf.text(clean, margin + thirdWidth, col2Y);
                    col2Y += 4.5;
                });
            }
            
            if (behaviorsText) {
                const heading = document.getElementById('behaviorsHeading').textContent;
                pdf.setFontSize(14); // 14pt for section heading
                pdf.setFont(undefined, 'bold');
                pdf.text(heading, margin + (thirdWidth * 2), col3Y);
                col3Y += 6;
                
                pdf.setFontSize(12); // 12pt for content
                pdf.setFont(undefined, 'normal');
                const items = behaviorsText.split('\n').filter(line => line.trim());
                items.forEach(item => {
                    const clean = item.trim().replace(/^[â€¢\-*]\s*/, '');
                    pdf.text(clean, margin + (thirdWidth * 2), col3Y);
                    col3Y += 4.5;
                });
            }
        }
        
        // ============ TOOLS AND TRENDS ============
        const tools = toolsInput.value.trim() ? toolsInput.value.split('\n').filter(line => line.trim()) : [];
        const trends = trendsInput.value.trim() ? trendsInput.value.split('\n').filter(line => line.trim()) : [];
        
        if (tools.length > 0 || trends.length > 0) {
            pdf.addPage('a4', 'landscape');
            yPos = margin + 5;
            
            const halfWidth = (pageWidth - (margin * 2) - 5) / 2;
            let leftY = yPos;
            let rightY = yPos;
            
            if (tools.length > 0) {
                const heading = document.getElementById('toolsHeading').textContent;
                pdf.setFontSize(14); // 14pt for section heading
                pdf.setFont(undefined, 'bold');
                pdf.text(heading, margin, leftY);
                leftY += 6;
                
                pdf.setFontSize(12); // 12pt for content
                pdf.setFont(undefined, 'normal');
                tools.forEach(tool => {
                    const clean = tool.trim().replace(/^[â€¢\-*]\s*/, '');
                    pdf.text(clean, margin, leftY);
                    leftY += 4.5;
                });
            }
            
            if (trends.length > 0) {
                const heading = document.getElementById('trendsHeading').textContent;
                pdf.setFontSize(14); // 14pt for section heading
                pdf.setFont(undefined, 'bold');
                pdf.text(heading, margin + halfWidth + 5, rightY);
                rightY += 6;
                
                pdf.setFontSize(12); // 12pt for content
                pdf.setFont(undefined, 'normal');
                trends.forEach(trend => {
                    const clean = trend.trim().replace(/^[â€¢\-*]\s*/, '');
                    pdf.text(clean, margin + halfWidth + 5, rightY);
                    rightY += 4.5;
                });
            }
        }
        
        // ============ ACRONYMS ============
        if (acronymsInput.value.trim()) {
            pdf.addPage('a4', 'landscape');
            yPos = margin + 5;
            
            const heading = document.getElementById('acronymsHeading').textContent;
            pdf.setFontSize(14); // 14pt for section heading
            pdf.setFont(undefined, 'bold');
            pdf.text(heading, margin, yPos);
            yPos += 6;
            
            pdf.setFontSize(12); // 12pt for content
            pdf.setFont(undefined, 'normal');
            const acronyms = acronymsInput.value.split('\n').filter(line => line.trim());
            acronyms.forEach(acronym => {
                const clean = acronym.trim().replace(/^[â€¢\-*]\s*/, '');
                pdf.text(clean, margin, yPos);
                yPos += 4.5;
            });
        }
        
        // ============ CAREER PATH ============
        const careerPathInput = document.getElementById('careerPathInput');
        if (careerPathInput && careerPathInput.value.trim()) {
            pdf.addPage('a4', 'landscape');
            yPos = margin + 5;
            
            const heading = document.getElementById('careerPathHeading').textContent;
            pdf.setFontSize(14); // 14pt for section heading
            pdf.setFont(undefined, 'bold');
            pdf.text(heading, margin, yPos);
            yPos += 6;
            
            pdf.setFontSize(12); // 12pt for content
            pdf.setFont(undefined, 'normal');
            const careerPathItems = careerPathInput.value.split('\n').filter(line => line.trim());
            careerPathItems.forEach(item => {
                const clean = item.trim().replace(/^[â€¢\-*]\s*/, '');
                pdf.text(clean, margin, yPos);
                yPos += 4.5;
            });
        }
        
        // ============ CUSTOM SECTIONS ============
        const customSectionsContainer = document.getElementById('customSectionsContainer');
        const customSectionDivs = customSectionsContainer.querySelectorAll('.section-container');
        customSectionDivs.forEach(sectionDiv => {
            const headingElement = sectionDiv.querySelector('h3');
            const textareaElement = sectionDiv.querySelector('textarea');
            
            if (headingElement && textareaElement && textareaElement.value.trim()) {
                pdf.addPage('a4', 'landscape');
                yPos = margin + 5;
                
                pdf.setFontSize(14); // 14pt for section heading
                pdf.setFont(undefined, 'bold');
                pdf.text(headingElement.textContent, margin, yPos);
                yPos += 6;
                
                pdf.setFontSize(12); // 12pt for content
                pdf.setFont(undefined, 'normal');
                const items = textareaElement.value.split('\n').filter(line => line.trim());
                items.forEach(item => {
                    const clean = item.trim().replace(/^[â€¢\-*]\s*/, '');
                    pdf.text(clean, margin, yPos);
                    yPos += 4.5;
                });
            }
        });
        
        // ============ TASK VERIFICATION APPENDIX (if mode = 'appendix') ============
        if (tvExportMode === 'appendix' && collectionMode === 'workshop') {
            // Check if we have valid results to include
            const validResults = Object.keys(workshopResults).filter(key => 
                workshopResults[key] && workshopResults[key].valid
            );
            
            if (validResults.length > 0) {
                // Start new page for appendix
                pdf.addPage();
                yPos = margin + 10;
                
                // Appendix title
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text('Task Verification & Training Priority Analysis (Appendix)', pageWidth / 2, yPos, { align: 'center' });
                yPos += 12;
                
                // Methodology Summary
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('Methodology Summary', margin, yPos);
                yPos += 8;
                
                pdf.setFontSize(11);
                pdf.setFont(undefined, 'normal');
                pdf.text(`Data Collection Mode: ${collectionMode === 'workshop' ? 'Workshop (Facilitated)' : 'Individual/Survey'}`, margin, yPos);
                yPos += 6;
                pdf.text(`Number of Participants: ${workshopParticipants}`, margin, yPos);
                yPos += 6;
                pdf.text(`Workflow Mode: ${workflowMode === 'standard' ? 'Standard (DACUM)' : 'Extended (DACUM)'}`, margin, yPos);
                yPos += 6;
                pdf.text(`Priority Formula: ${priorityFormula === 'if' ? 'Importance Ã— Frequency' : 'Importance Ã— Frequency Ã— Difficulty'}`, margin, yPos);
                yPos += 12;
                
                // Priority Rankings Table
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('Priority Rankings', margin, yPos);
                yPos += 8;
                
                // Get sorted results
                const sortedResults = [];
                validResults.forEach(taskKey => {
                    const result = workshopResults[taskKey];
                    
                    // Use stored duty and task titles (with backward compatibility)
                    let dutyText = result.dutyTitle;
                    let taskText = result.taskTitle;
                    
                    // Backward compatibility: if not stored, look up from DOM
                    if (!dutyText || !taskText) {
                        const taskParts = taskKey.split('_task_');
                        const dutyId = taskParts[0];
                        
                        if (!dutyText) {
                            const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                            dutyText = dutyInput ? dutyInput.value.trim() : 'Unassigned';
                        }
                        
                        if (!taskText) {
                            const taskInput = document.querySelector(`[data-task-id="${taskKey}"]`);
                            taskText = taskInput ? taskInput.value.trim() : 'Unassigned';
                        }
                    }
                    
                    sortedResults.push({
                        duty: dutyText,
                        task: taskText,
                        meanI: result.meanImportance,
                        meanF: result.meanFrequency,
                        meanD: result.meanDifficulty,
                        priority: result.priorityIndex
                    });
                });
                
                // Sort by priority descending
                sortedResults.sort((a, b) => b.priority - a.priority);
                
                // Table headers
                const colWidths = [15, 50, 75, 25, 25, 25, 25];
                const headers = ['Rank', 'Duty', 'Task', 'Mean I', 'Mean F', 'Mean D', 'Priority'];
                
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                let xPos = margin;
                headers.forEach((header, i) => {
                    pdf.text(header, xPos, yPos);
                    xPos += colWidths[i];
                });
                yPos += 6;
                
                // Table rows
                pdf.setFont(undefined, 'normal');
                sortedResults.forEach((row, index) => {
                    if (yPos > pageHeight - 20) {
                        pdf.addPage();
                        yPos = margin + 10;
                    }
                    
                    xPos = margin;
                    pdf.text(`#${index + 1}`, xPos, yPos);
                    xPos += colWidths[0];
                    
                    // Truncate long text
                    const dutyTrunc = row.duty.length > 20 ? row.duty.substring(0, 17) + '...' : row.duty;
                    pdf.text(dutyTrunc, xPos, yPos);
                    xPos += colWidths[1];
                    
                    const taskTrunc = row.task.length > 40 ? row.task.substring(0, 37) + '...' : row.task;
                    pdf.text(taskTrunc, xPos, yPos);
                    xPos += colWidths[2];
                    
                    pdf.text(row.meanI !== null ? row.meanI.toFixed(2) : 'N/A', xPos, yPos);
                    xPos += colWidths[3];
                    pdf.text(row.meanF !== null ? row.meanF.toFixed(2) : 'N/A', xPos, yPos);
                    xPos += colWidths[4];
                    pdf.text(row.meanD !== null ? row.meanD.toFixed(2) : 'N/A', xPos, yPos);
                    xPos += colWidths[5];
                    pdf.text(row.priority !== null ? row.priority.toFixed(2) : 'N/A', xPos, yPos);
                    
                    yPos += 5;
                });
                
                yPos += 8;
                
                // Duty-Level Summary Section
                if (yPos > pageHeight - 30) {
                    pdf.addPage();
                    yPos = margin + 10;
                }
                
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('Duty-Level Summary', margin, yPos);
                yPos += 5;
                
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'italic');
                pdf.text(`Training Load Method: ${trainingLoadMethod === 'advanced' ? 'Advanced (Î£ Priority Ã— Difficulty)' : 'Simple (Avg Priority Ã— Tasks)'}`, margin, yPos);
                yPos += 8;
                
                // Aggregate duty-level data
                const dutyMap = {};
                Object.keys(workshopResults).forEach(taskKey => {
                    const result = workshopResults[taskKey];
                    if (result && result.valid) {
                        let dutyId = result.dutyId || taskKey.split('_task_')[0];
                        let dutyTitle = result.dutyTitle;
                        
                        if (!dutyTitle) {
                            const dutyInput = document.querySelector(`[data-duty-id="${dutyId}"]`);
                            dutyTitle = dutyInput ? dutyInput.value.trim() : 'Unassigned';
                        }
                        
                        if (!dutyMap[dutyId]) {
                            dutyMap[dutyId] = {
                                dutyTitle: dutyTitle,
                                validTasks: 0,
                                prioritySum: 0,
                                difficultySum: 0,
                                tasks: []
                            };
                        }
                        
                        dutyMap[dutyId].validTasks++;
                        dutyMap[dutyId].prioritySum += result.priorityIndex;
                        dutyMap[dutyId].difficultySum += result.meanDifficulty;
                        dutyMap[dutyId].tasks.push({
                            priorityIndex: result.priorityIndex,
                            meanDifficulty: result.meanDifficulty
                        });
                    }
                });
                
                const dutyResults = [];
                Object.keys(dutyMap).forEach(dutyId => {
                    const duty = dutyMap[dutyId];
                    const avgPriority = duty.prioritySum / duty.validTasks;
                    
                    let trainingLoad = 0;
                    if (trainingLoadMethod === 'advanced') {
                        trainingLoad = duty.tasks.reduce((sum, t) => sum + (t.priorityIndex * t.meanDifficulty), 0);
                    } else {
                        trainingLoad = avgPriority * duty.validTasks;
                    }
                    
                    dutyResults.push({
                        dutyTitle: duty.dutyTitle,
                        validTasks: duty.validTasks,
                        avgPriority: avgPriority,
                        trainingLoad: trainingLoad
                    });
                });
                
                dutyResults.sort((a, b) => b.avgPriority - a.avgPriority);
                
                // Duty table headers
                const dutyColWidths = [80, 30, 40, 45];
                const dutyHeaders = ['Duty Title', 'Tasks', 'Avg Priority', 'Training Load'];
                
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'bold');
                let dutyXPos = margin;
                dutyHeaders.forEach((header, i) => {
                    pdf.text(header, dutyXPos, yPos);
                    dutyXPos += dutyColWidths[i];
                });
                yPos += 6;
                
                // Duty table rows
                pdf.setFont(undefined, 'normal');
                dutyResults.forEach((duty) => {
                    if (yPos > pageHeight - 20) {
                        pdf.addPage();
                        yPos = margin + 10;
                    }
                    
                    dutyXPos = margin;
                    const dutyTitleTrunc = duty.dutyTitle.length > 35 ? duty.dutyTitle.substring(0, 32) + '...' : duty.dutyTitle;
                    pdf.text(dutyTitleTrunc, dutyXPos, yPos);
                    dutyXPos += dutyColWidths[0];
                    
                    pdf.text(duty.validTasks.toString(), dutyXPos, yPos);
                    dutyXPos += dutyColWidths[1];
                    
                    pdf.text(duty.avgPriority.toFixed(2), dutyXPos, yPos);
                    dutyXPos += dutyColWidths[2];
                    
                    pdf.text(duty.trainingLoad.toFixed(2), dutyXPos, yPos);
                    
                    yPos += 5;
                });
                
                yPos += 8;
                
                // Notes
                pdf.setFontSize(12);
                pdf.setFont(undefined, 'bold');
                pdf.text('Notes', margin, yPos);
                yPos += 6;
                
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'normal');
                const notes = [
                    'Weighted Mean = Î£(value Ã— count) Ã· total responses',
                    'Priority Index calculated using selected formula',
                    'Higher priority values indicate greater training importance',
                    'Results based on DACUM methodology'
                ];
                notes.forEach(note => {
                    if (yPos > pageHeight - 15) {
                        pdf.addPage();
                        yPos = margin + 10;
                    }
                    pdf.text(`â€¢ ${note}`, margin, yPos);
                    yPos += 5;
                });
            }
        }
        
        // ============ VERIFIED LIVE WORKSHOP RESULTS APPENDIX ============
        if (tvExportMode === 'appendix' && hasVerifiedResults) {
            // Start new page for verified results appendix
            pdf.addPage();
            yPos = margin + 10;
            
            // Appendix title
            pdf.setFontSize(16);
            pdf.setFont(undefined, 'bold');
            pdf.text('DACUM Live Pro - Verified (Post-Vote) Results (Appendix)', pageWidth / 2, yPos, { align: 'center' });
            yPos += 12;
            
            // Metadata
            pdf.setFontSize(11);
            pdf.setFont(undefined, 'normal');
            pdf.text(`Occupation: ${lwFinalizedData.occupation}`, margin, yPos);
            yPos += 6;
            pdf.text(`Job Title: ${lwFinalizedData.jobTitle}`, margin, yPos);
            yPos += 6;
            pdf.text(`Date: ${new Date().toLocaleDateString()}`, margin, yPos);
            yPos += 6;
            const vFormula = lwFinalizedData.priorityFormula || 'if';
            const vFormulaText = vFormula === 'ifd' ? 'Importance Ã— Frequency Ã— Difficulty' : 'Importance Ã— Frequency';
            pdf.text(`Priority Formula: ${vFormulaText}`, margin, yPos);
            yPos += 6;
            pdf.text(`Total Participants: ${lwAggregatedResults.totalVotes}`, margin, yPos);
            yPos += 12;
            
            // Collect all verified tasks with metrics
            const verifiedTasks = [];
            Object.keys(lwFinalizedData.duties).forEach(dutyId => {
                const duty = lwFinalizedData.duties[dutyId];
                duty.tasks.forEach(task => {
                    if (task.priorityIndex !== undefined) {
                        verifiedTasks.push({
                            dutyTitle: duty.title,
                            taskText: task.text,
                            meanImportance: task.meanImportance,
                            meanFrequency: task.meanFrequency,
                            meanDifficulty: task.meanDifficulty,
                            priorityIndex: task.priorityIndex,
                            rank: task.rank
                        });
                    }
                });
            });
            
            verifiedTasks.sort((a, b) => a.rank - b.rank);
            
            // Table header
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Rank', margin, yPos);
            pdf.text('Duty', margin + 15, yPos);
            pdf.text('Task', margin + 60, yPos);
            pdf.text('I', margin + 140, yPos);
            pdf.text('F', margin + 150, yPos);
            pdf.text('D', margin + 160, yPos);
            pdf.text('PI', margin + 170, yPos);
            yPos += 5;
            pdf.line(margin, yPos, pageWidth - margin, yPos);
            yPos += 3;
            
            // Table rows
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(8);
            
            verifiedTasks.forEach(task => {
                // Check if need new page
                if (yPos + 8 > pageHeight - margin) {
                    pdf.addPage();
                    yPos = margin;
                }
                
                pdf.text(String(task.rank), margin, yPos);
                const dutyLines = pdf.splitTextToSize(task.dutyTitle, 40);
                pdf.text(dutyLines[0] || '', margin + 15, yPos);
                const taskLines = pdf.splitTextToSize(task.taskText, 75);
                pdf.text(taskLines[0] || '', margin + 60, yPos);
                pdf.text(task.meanImportance.toFixed(2), margin + 140, yPos);
                pdf.text(task.meanFrequency.toFixed(2), margin + 150, yPos);
                pdf.text(task.meanDifficulty.toFixed(2), margin + 160, yPos);
                pdf.text(task.priorityIndex.toFixed(2), margin + 170, yPos);
                yPos += 6;
            });
        }
        
        // ============ COMPETENCY CLUSTERS SECTION ============
        if (clusteringData.clusters && clusteringData.clusters.length > 0) {
            pdf.addPage();
            yPos = margin + 5;
            
            pdf.setFontSize(16);
            pdf.setFont(undefined, 'bold');
            pdf.text('Competency Clusters', pageWidth / 2, yPos, { align: 'center' });
            yPos += 10;
            
            clusteringData.clusters.forEach(cluster => {
                // Check if need new page
                if (yPos + 20 > pageHeight - margin) {
                    pdf.addPage();
                    yPos = margin + 5;
                }
                
                // Cluster header
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text(cluster.name, margin, yPos);
                yPos += 7;
                
                // Cluster tasks
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'normal');
                
                cluster.tasks.forEach((task, index) => {
                    if (yPos + 6 > pageHeight - margin) {
                        pdf.addPage();
                        yPos = margin + 5;
                    }
                    
                    const taskCode = getTaskCode(task.id);
                    const taskText = `${index + 1}. ${taskCode}: ${task.text}`;
                    const lines = pdf.splitTextToSize(taskText, pageWidth - 2 * margin - 5);
                    
                    lines.forEach(line => {
                        if (yPos + 5 > pageHeight - margin) {
                            pdf.addPage();
                            yPos = margin + 5;
                        }
                        pdf.text(line, margin + 5, yPos);
                        yPos += 5;
                    });
                });
                
                yPos += 5;
            });
        }
        
        pdf.save(`${occupationTitleInput.value}_${jobTitleInput.value}_DACUM_Chart.pdf`);
        showStatus('PDF exported successfully! âœ“', 'success');
        
    } catch (error) {
        console.error('Error generating PDF:', error);
        showStatus('Error generating PDF: ' + error.message, 'error');
    }
}


        // Check if docx library loaded successfully
        window.addEventListener('load', function() {
            setTimeout(function() {
                if (typeof window.docx === 'undefined') {
                    console.error('Warning: docx library failed to load');
                } else {
                    console.log('docx library loaded successfully');
                }
            }, 1000);
        });

// ===== LIVE WORKSHOP MODULE - JAVASCRIPT =====
// This module handles live voting sessions with Railway backend
// Integrated into DACUM v3.9 without modifying existing functionality

// Live Workshop State Variables
let lwSessionId = null;
let lwIsFinalized = false;
let lwFinalizedData = null;
let lwAggregatedResults = null;

// Backend API endpoint
const LW_API_BASE = 'https://live-session-backend-production.up.railway.app/api';

// ===== LIVE WORKSHOP - INITIALIZATION =====
// Show Live Workshop section only in Workshop mode
function lwCheckAndShowSection() {
    const collectionMode = document.querySelector('input[name="collectionMode"]:checked')?.value;
    const lwSection = document.getElementById('liveWorkshopSection');
    
    if (collectionMode === 'workshop') {
        lwSection.style.display = 'block';
    } else {
        lwSection.style.display = 'none';
    }
}

// Override collection mode change to show/hide Live Workshop
const originalUpdateCollectionMode = window.updateCollectionMode;
window.updateCollectionMode = function() {
    if (originalUpdateCollectionMode) {
        originalUpdateCollectionMode();
    }
    lwCheckAndShowSection();
};

// ===== LIVE WORKSHOP - PHASE 1: FINALIZATION =====
async function lwFinalizeAndCreateSession() {
    // Get occupation and job titles from v3.9 with robust fallback
    // Try multiple possible field IDs to ensure compatibility
    const occupationField = document.getElementById('occupationTitleInput') || document.getElementById('occupationTitle');
    const jobTitleField = document.getElementById('jobTitleInput') || document.getElementById('jobTitle');
    
    const occupation = occupationField?.value.trim() || '';
    const jobTitle = jobTitleField?.value.trim() || '';
    
    // Validation - only fail if both sources are empty
    if (!occupation || !jobTitle) {
        showStatus('Please enter Occupation Title and Job Title in the Basic Information tab', 'error');
        return;
    }
    
    // Get all duties and tasks from v3.9 DOM
    const duties = lwExtractDutiesAndTasks();
    
    if (Object.keys(duties).length === 0) {
        showStatus('Please add at least one duty with tasks in the Duties & Tasks tab', 'error');
        return;
    }
    
    // Validate each duty has title and tasks
    let valid = true;
    Object.keys(duties).forEach(dutyId => {
        const duty = duties[dutyId];
        if (!duty.title.trim()) {
            showStatus(`Duty "${dutyId}" needs a title`, 'error');
            valid = false;
        }
        if (duty.tasks.length === 0) {
            showStatus(`Duty "${duty.title}" needs at least one task`, 'error');
            valid = false;
        }
        duty.tasks.forEach(task => {
            if (!task.text.trim()) {
                showStatus(`Please fill in all task descriptions`, 'error');
                valid = false;
            }
        });
    });
    
    if (!valid) return;
    
    // Capture the selected priority formula
    const selectedFormula = document.querySelector('input[name="priorityFormula"]:checked')?.value || 'if';
    
    // Create finalized snapshot
    lwFinalizedData = {
        occupation: occupation,
        jobTitle: jobTitle,
        priorityFormula: selectedFormula,
        duties: JSON.parse(JSON.stringify(duties)) // Deep copy
    };
    
    // Lock the finalization
    lwIsFinalized = true;
    document.getElementById('btnLWFinalize').disabled = true;
    
    // Generate session ID
    lwSessionId = lwGenerateId();
    
    // Send to backend
    try {
        const response = await fetch(`${LW_API_BASE}/create-session`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                sessionId: lwSessionId,
                data: lwFinalizedData
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            showStatus('âœ… Live Workshop session created successfully!', 'success');
            
            // Show session info
            document.getElementById('lwStep1-finalize').style.display = 'none';
            document.getElementById('lwStep2-session').style.display = 'block';
            document.getElementById('lwSessionId').textContent = lwSessionId;
            
            // Generate participant link to separate participant file
            // Get directory path without filename
            const currentPath = window.location.pathname;
            const directory = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
            const participantFileUrl = window.location.origin + directory + 'DACUM_LiveWorkshop_Participant.html';
            const participantUrl = `${participantFileUrl}?lwsession=${lwSessionId}`;
            document.getElementById('lwParticipantLink').textContent = participantUrl;
            
        } else {
            throw new Error(result.error || 'Failed to create session');
        }
        
    } catch (error) {
        console.error('Error creating session:', error);
        showStatus(`Error creating session: ${error.message}`, 'error');
        
        // Rollback on error
        lwIsFinalized = false;
        lwSessionId = null;
        document.getElementById('btnLWFinalize').disabled = false;
    }
}

// ===== LIVE WORKSHOP - EXTRACT DUTIES/TASKS FROM V3.9 DOM =====
function lwExtractDutiesAndTasks() {
    const duties = {};
    
    // Get all duty containers from v3.9
    const dutyContainers = document.querySelectorAll('.duty-row');
    
    dutyContainers.forEach((dutyContainer, index) => {
        const dutyId = dutyContainer.id;
        const dutyInput = dutyContainer.querySelector(`input[data-duty-id="${dutyId}"]`);
        const dutyTitle = dutyInput ? dutyInput.value.trim() : '';
        
        if (!dutyTitle) return; // Skip empty duties
        
        const tasks = [];
        const taskInputs = dutyContainer.querySelectorAll(`input[data-task-id^="${dutyId}_"]`);
        
        taskInputs.forEach((taskInput, taskIndex) => {
            const taskText = taskInput.value.trim();
            if (taskText) {
                tasks.push({
                    id: taskInput.getAttribute('data-task-id'),
                    text: taskText
                });
            }
        });
        
        if (tasks.length > 0) {
            duties[dutyId] = {
                title: dutyTitle,
                tasks: tasks
            };
        }
    });
    
    return duties;
}

// ===== LIVE WORKSHOP - HELPER FUNCTIONS =====
function lwGenerateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

function lwCopyLink() {
    const link = document.getElementById('lwParticipantLink').textContent;
    navigator.clipboard.writeText(link).then(() => {
        showStatus('âœ… Participant link copied to clipboard!', 'success');
    }).catch(err => {
        showStatus('Failed to copy link', 'error');
    });
}

// ===== LIVE WORKSHOP - PHASE 2: FETCH RESULTS =====
// ===== LIVE WORKSHOP - APPLY RESULTS TO DATA MODEL =====
function lwApplyVotingResultsToDataModel() {
    if (!lwFinalizedData || !lwAggregatedResults) return;
    
    const { taskResults } = lwAggregatedResults;
    const formula = lwFinalizedData.priorityFormula || 'if';
    
    // Recalculate priority index for all tasks using the stored formula
    const allTasksWithResults = [];
    Object.keys(taskResults).forEach(taskId => {
        const voteData = taskResults[taskId];
        let priorityIndex;
        
        if (formula === 'ifd') {
            // IFD: Importance Ã— Frequency Ã— Difficulty
            priorityIndex = voteData.avgImportance * voteData.avgFrequency * voteData.avgDifficulty;
        } else {
            // IF: Importance Ã— Frequency (default)
            priorityIndex = voteData.avgImportance * voteData.avgFrequency;
        }
        
        allTasksWithResults.push({
            taskId: taskId,
            ...voteData,
            priorityIndex: priorityIndex
        });
    });
    
    // Sort all tasks globally by recalculated priority to assign ranks
    allTasksWithResults.sort((a, b) => b.priorityIndex - a.priorityIndex);
    
    // Assign global ranks
    const taskRanks = {};
    allTasksWithResults.forEach((task, index) => {
        taskRanks[task.taskId] = index + 1;
    });
    
    // Update each duty: add voting metrics with recalculated priority and reorder tasks
    Object.keys(lwFinalizedData.duties).forEach(dutyId => {
        const duty = lwFinalizedData.duties[dutyId];
        
        // Add voting metrics to each task
        duty.tasks.forEach(task => {
            const voteData = taskResults[task.id];
            if (voteData) {
                let priorityIndex;
                if (formula === 'ifd') {
                    priorityIndex = voteData.avgImportance * voteData.avgFrequency * voteData.avgDifficulty;
                } else {
                    priorityIndex = voteData.avgImportance * voteData.avgFrequency;
                }
                
                task.meanImportance = voteData.avgImportance;
                task.meanFrequency = voteData.avgFrequency;
                task.meanDifficulty = voteData.avgDifficulty;
                task.priorityIndex = priorityIndex;
                task.rank = taskRanks[task.id];
            }
        });
        
        // Sort tasks by recalculated priority index (descending)
        duty.tasks.sort((a, b) => (b.priorityIndex || 0) - (a.priorityIndex || 0));
    });
    
    // Update DOM to reflect new task order
    lwUpdateDOMWithReorderedTasks();
}

// ===== LIVE WORKSHOP - UPDATE DOM WITH REORDERED TASKS =====
function lwUpdateDOMWithReorderedTasks() {
    Object.keys(lwFinalizedData.duties).forEach(dutyId => {
        const duty = lwFinalizedData.duties[dutyId];
        const dutyContainer = document.getElementById(dutyId);
        
        if (!dutyContainer) return;
        
        // Find the task list container within this duty
        const taskListContainer = dutyContainer.querySelector('.task-list');
        if (!taskListContainer) return;
        
        // Clear existing tasks
        taskListContainer.innerHTML = '';
        
        // Re-add tasks in new order
        duty.tasks.forEach((task, index) => {
            const taskDiv = document.createElement('div');
            taskDiv.className = 'task-item';
            taskDiv.innerHTML = `
                <input type="text" 
                       data-task-id="${task.id}" 
                       value="${task.text.replace(/"/g, '&quot;')}" 
                       placeholder="Enter task description" 
                       disabled>
            `;
            taskListContainer.appendChild(taskDiv);
        });
    });
}

async function lwFetchResults() {
    if (!lwSessionId) {
        showStatus('No active session', 'error');
        return;
    }
    
    try {
        const response = await fetch(`${LW_API_BASE}/get-results/${lwSessionId}`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            lwAggregatedResults = result.data;
            
            // Apply voting results to the underlying data model
            lwApplyVotingResultsToDataModel();
            
            lwDisplayResults();
            showStatus('âœ… Results refreshed and tasks reordered by priority', 'success');
            
            // Show export buttons
            document.getElementById('lwExportButtons').style.display = 'block';
        } else {
            throw new Error(result.error || 'Failed to fetch results');
        }
        
    } catch (error) {
        console.error('Error fetching results:', error);
        showStatus(`Error fetching results: ${error.message}`, 'error');
    }
}

// ===== LIVE WORKSHOP - DISPLAY RESULTS =====
function lwDisplayResults() {
    const container = document.getElementById('lwResultsContainer');
    
    if (!lwAggregatedResults) {
        container.innerHTML = '<p style="color: #999; font-style: italic; text-align: center; padding: 30px;">No votes received yet.</p>';
        return;
    }
    
    const { totalVotes } = lwAggregatedResults;
    
    if (totalVotes === 0) {
        container.innerHTML = '<p style="color: #999; font-style: italic; text-align: center; padding: 30px;">No votes received yet. Share the participant link to start collecting votes.</p>';
        return;
    }
    
    // Collect all tasks with recalculated metrics from lwFinalizedData
    const allTasks = [];
    Object.keys(lwFinalizedData.duties).forEach(dutyId => {
        const duty = lwFinalizedData.duties[dutyId];
        duty.tasks.forEach(task => {
            if (task.priorityIndex !== undefined) {
                allTasks.push({
                    dutyTitle: duty.title,
                    taskText: task.text,
                    avgImportance: task.meanImportance,
                    avgFrequency: task.meanFrequency,
                    avgDifficulty: task.meanDifficulty,
                    priorityIndex: task.priorityIndex,
                    rank: task.rank
                });
            }
        });
    });
    
    // Sort by rank (already sorted in data model, but ensure consistency)
    allTasks.sort((a, b) => a.rank - b.rank);
    
    const formula = lwFinalizedData.priorityFormula || 'if';
    const formulaText = formula === 'ifd' 
        ? 'Average Importance Ã— Average Frequency Ã— Average Difficulty'
        : 'Average Importance Ã— Average Frequency';
    
    let html = `
        <div style="background: white; padding: 25px; border-radius: 12px; border: 2px solid #667eea;">
            <h3 style="color: #667eea; margin: 0 0 20px 0; text-align: center;">ğŸ“Š Voting Results Summary</h3>
            <div style="text-align: center; margin-bottom: 25px;">
                <div style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px 30px; border-radius: 12px;">
                    <div style="font-size: 0.9em; opacity: 0.9; margin-bottom: 5px;">Total Participants</div>
                    <div style="font-size: 2.5em; font-weight: 700;">${totalVotes}</div>
                </div>
            </div>
            
            <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                    <thead>
                        <tr style="background: #f9fafb; border-bottom: 2px solid #e5e7eb;">
                            <th style="padding: 12px; text-align: left; font-weight: 600; color: #667eea;">Rank</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600; color: #667eea;">Duty</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600; color: #667eea;">Task</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600; color: #667eea;">Avg<br>Importance</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600; color: #667eea;">Avg<br>Frequency</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600; color: #667eea;">Avg<br>Difficulty</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600; color: #667eea;">Priority<br>Index</th>
                        </tr>
                    </thead>
                    <tbody>
    `;
    
    allTasks.forEach((task, index) => {
        const rankColor = index < 3 ? '#10b981' : '#64748b';
        const rankBg = index < 3 ? '#d1fae5' : '#f1f5f9';
        
        html += `
            <tr style="border-bottom: 1px solid #e5e7eb;">
                <td style="padding: 12px;">
                    <span style="background: ${rankBg}; color: ${rankColor}; padding: 6px 12px; border-radius: 20px; font-weight: 700; font-size: 0.95em;">
                        #${task.rank}
                    </span>
                </td>
                <td style="padding: 12px; color: #334155; font-weight: 500;">${lwEscapeHtml(task.dutyTitle)}</td>
                <td style="padding: 12px; color: #475569;">${lwEscapeHtml(task.taskText)}</td>
                <td style="padding: 12px; text-align: center; font-weight: 600; color: #667eea;">${task.avgImportance.toFixed(2)}</td>
                <td style="padding: 12px; text-align: center; font-weight: 600; color: #667eea;">${task.avgFrequency.toFixed(2)}</td>
                <td style="padding: 12px; text-align: center; font-weight: 600; color: #667eea;">${task.avgDifficulty.toFixed(2)}</td>
                <td style="padding: 12px; text-align: center; font-weight: 700; font-size: 1.1em; color: #10b981;">${task.priorityIndex.toFixed(2)}</td>
            </tr>
        `;
    });
    
    html += `
                    </tbody>
                </table>
            </div>
            
            <div style="margin-top: 25px; padding: 15px; background: #f0f7ff; border-radius: 8px; border-left: 4px solid #667eea;">
                <p style="margin: 0; color: #334155; font-size: 0.9em; line-height: 1.6;">
                    <strong>Priority Index</strong> = ${formulaText}<br>
                    <strong>Higher values</strong> indicate greater training priority and importance for the occupation.
                </p>
            </div>
        </div>
    `;
    
    container.innerHTML = html;
}

function lwEscapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ===== LIVE WORKSHOP - EXPORT FUNCTIONS =====

// Export JSON with voting data
function lwExportJSON() {
    if (!lwFinalizedData || !lwAggregatedResults) {
        showStatus('No results available to export', 'error');
        return;
    }
    
    // Export in v3.9-compatible format with tasks reordered and voting metrics embedded
    const exportData = {
        version: '1.0',
        savedDate: new Date().toISOString(),
        liveWorkshopSession: {
            sessionId: lwSessionId,
            totalParticipants: lwAggregatedResults.totalVotes,
            exportDate: new Date().toISOString()
        },
        chartInfo: {
            dacumDate: document.getElementById('dacumDate')?.value || '',
            producedFor: document.getElementById('producedFor')?.value || '',
            producedBy: document.getElementById('producedBy')?.value || '',
            occupationTitle: lwFinalizedData.occupation,
            jobTitle: lwFinalizedData.jobTitle,
            sector: document.getElementById('sector')?.value || '',
            context: document.getElementById('context')?.value || '',
            producedForImage: null,
            producedByImage: null
        },
        duties: [],
        additionalInfo: {
            headings: {
                knowledge: document.getElementById('knowledgeHeading')?.textContent || 'Knowledge & Subject Matter',
                skills: document.getElementById('skillsHeading')?.textContent || 'Skills',
                behaviors: document.getElementById('behaviorsHeading')?.textContent || 'Behaviors & Attitudes',
                tools: document.getElementById('toolsHeading')?.textContent || 'Tools & Equipment',
                trends: document.getElementById('trendsHeading')?.textContent || 'Future Trends & Technology',
                acronyms: document.getElementById('acronymsHeading')?.textContent || 'Acronyms',
                careerPath: document.getElementById('careerPathHeading')?.textContent || 'Career Path'
            },
            knowledge: document.getElementById('knowledgeInput')?.value || '',
            skills: document.getElementById('skillsInput')?.value || '',
            behaviors: document.getElementById('behaviorsInput')?.value || '',
            tools: document.getElementById('toolsInput')?.value || '',
            trends: document.getElementById('trendsInput')?.value || '',
            acronyms: document.getElementById('acronymsInput')?.value || '',
            careerPath: document.getElementById('careerPathInput')?.value || ''
        },
        customSections: [],
        verification: {
            collectionMode: 'workshop',
            workflowMode: 'standard',
            ratings: {},
            taskMetadata: {},
            workshopParticipants: lwAggregatedResults.totalVotes,
            priorityFormula: lwFinalizedData.priorityFormula || 'if',
            trainingLoadMethod: 'advanced',
            workshopCounts: {},
            workshopResults: {}
        }
    };
    
    // Convert duties object to array format with tasks as strings (in priority order)
    Object.keys(lwFinalizedData.duties).forEach(dutyId => {
        const duty = lwFinalizedData.duties[dutyId];
        
        // Tasks are already sorted by priority in lwFinalizedData after lwApplyVotingResultsToDataModel
        // Export tasks as simple strings for compatibility
        const taskStrings = duty.tasks.map(task => task.text);
        
        exportData.duties.push({
            duty: duty.title,
            tasks: taskStrings
        });
        
        // Store voting metrics in verification.workshopResults
        duty.tasks.forEach(task => {
            if (task.meanImportance !== undefined) {
                exportData.verification.workshopResults[task.id] = {
                    valid: true,
                    dutyId: dutyId,
                    dutyTitle: duty.title,
                    taskText: task.text,
                    meanImportance: task.meanImportance,
                    meanFrequency: task.meanFrequency,
                    meanDifficulty: task.meanDifficulty,
                    priorityIndex: task.priorityIndex,
                    rank: task.rank,
                    totalResponses: lwAggregatedResults.totalVotes
                };
            }
        });
    });
    
    const json = JSON.stringify(exportData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${lwFinalizedData.occupation}_${lwFinalizedData.jobTitle}_LiveWorkshop_Results.json`.replace(/[^a-z0-9_]/gi, '_');
    a.click();
    URL.revokeObjectURL(url);
    
    showStatus('âœ… JSON file exported with tasks in priority order!', 'success');
}

// Export CSV with tasks and scores
function lwExportCSV() {
    if (!lwAggregatedResults) {
        showStatus('No results available to export', 'error');
        return;
    }
    
    const { taskResults } = lwAggregatedResults;
    
    // Sort by priority index
    const sortedTasks = Object.keys(taskResults)
        .map(taskKey => taskResults[taskKey])
        .sort((a, b) => b.priorityIndex - a.priorityIndex);
    
    // CSV Header
    let csv = 'Rank,Duty,Task,Avg Importance,Avg Frequency,Avg Difficulty,Priority Index\n';
    
    // CSV Rows
    sortedTasks.forEach((task, index) => {
        csv += `${index + 1},"${lwEscapeCSV(task.dutyTitle)}","${lwEscapeCSV(task.taskText)}",${task.avgImportance.toFixed(2)},${task.avgFrequency.toFixed(2)},${task.avgDifficulty.toFixed(2)},${task.priorityIndex.toFixed(2)}\n`;
    });
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${lwFinalizedData.occupation}_${lwFinalizedData.jobTitle}_LiveWorkshop_Results.csv`;
    a.click();
    URL.revokeObjectURL(url);
    
    showStatus('âœ… CSV file exported successfully!', 'success');
}

// Download snapshot (pre-voting backup)
function lwExportSnapshot() {
    if (!lwFinalizedData) {
        showStatus('No snapshot available to export', 'error');
        return;
    }
    
    // Export in v3.9-compatible format (pre-voting snapshot without results)
    const snapshotData = {
        version: '1.0',
        savedDate: new Date().toISOString(),
        liveWorkshopSession: {
            sessionId: lwSessionId,
            type: 'PRE-VOTING SNAPSHOT',
            snapshotDate: new Date().toISOString()
        },
        chartInfo: {
            dacumDate: document.getElementById('dacumDate')?.value || '',
            producedFor: document.getElementById('producedFor')?.value || '',
            producedBy: document.getElementById('producedBy')?.value || '',
            occupationTitle: lwFinalizedData.occupation,
            jobTitle: lwFinalizedData.jobTitle,
            sector: document.getElementById('sector')?.value || '',
            context: document.getElementById('context')?.value || '',
            producedForImage: null,
            producedByImage: null
        },
        duties: [],
        additionalInfo: {
            headings: {
                knowledge: document.getElementById('knowledgeHeading')?.textContent || 'Knowledge & Subject Matter',
                skills: document.getElementById('skillsHeading')?.textContent || 'Skills',
                behaviors: document.getElementById('behaviorsHeading')?.textContent || 'Behaviors & Attitudes',
                tools: document.getElementById('toolsHeading')?.textContent || 'Tools & Equipment',
                trends: document.getElementById('trendsHeading')?.textContent || 'Future Trends & Technology',
                acronyms: document.getElementById('acronymsHeading')?.textContent || 'Acronyms',
                careerPath: document.getElementById('careerPathHeading')?.textContent || 'Career Path'
            },
            knowledge: document.getElementById('knowledgeInput')?.value || '',
            skills: document.getElementById('skillsInput')?.value || '',
            behaviors: document.getElementById('behaviorsInput')?.value || '',
            tools: document.getElementById('toolsInput')?.value || '',
            trends: document.getElementById('trendsInput')?.value || '',
            acronyms: document.getElementById('acronymsInput')?.value || '',
            careerPath: document.getElementById('careerPathInput')?.value || ''
        },
        customSections: []
    };
    
    // Convert duties object to array format for v3.9
    Object.keys(lwFinalizedData.duties).forEach(dutyId => {
        const duty = lwFinalizedData.duties[dutyId];
        const tasks = duty.tasks.map(task => task.text);
        
        snapshotData.duties.push({
            duty: duty.title,
            tasks: tasks
        });
    });
    
    const json = JSON.stringify(snapshotData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${lwFinalizedData.occupation}_${lwFinalizedData.jobTitle}_PreVoting_Snapshot.json`.replace(/[^a-z0-9_]/gi, '_');
    a.click();
    URL.revokeObjectURL(url);
    
    showStatus('âœ… Snapshot downloaded successfully! (v3.9 compatible format)', 'success');
}

function lwCloseVoting() {
    if (!lwSessionId) {
        showStatus('No active session found', 'error');
        return;
    }
    
    if (!confirm('Are you sure you want to close this voting session? Participants will no longer be able to submit or change votes.')) {
        return;
    }
    
    localStorage.setItem('dacumVotingClosed_' + lwSessionId, 'true');
    
    showStatus('âœ… Voting session closed successfully. Participants can no longer submit votes.', 'success');
}


// ===== LIVE WORKSHOP - VERIFIED RESULTS PDF EXPORT =====
async function lwExportVerifiedPDF() {
    if (!lwFinalizedData || !lwAggregatedResults) {
        showStatus('No verified results available. Please refresh voting results first.', 'error');
        return;
    }
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 15;
    const contentWidth = pageWidth - 2 * margin;
    let yPos = margin;
    
    // Helper to add new page if needed
    const checkPageBreak = (requiredSpace) => {
        if (yPos + requiredSpace > pageHeight - margin) {
            doc.addPage();
            yPos = margin;
            return true;
        }
        return false;
    };
    
    // Title
    doc.setFontSize(18);
    doc.setFont('helvetica', 'bold');
    doc.text('DACUM Live Pro', pageWidth / 2, yPos, { align: 'center' });
    yPos += 8;
    doc.setFontSize(14);
    doc.text('Verified (Post-Vote) Results', pageWidth / 2, yPos, { align: 'center' });
    yPos += 10;
    
    // Metadata
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(`Occupation: ${lwFinalizedData.occupation}`, margin, yPos);
    yPos += 6;
    doc.text(`Job Title: ${lwFinalizedData.jobTitle}`, margin, yPos);
    yPos += 6;
    doc.text(`Date: ${new Date().toLocaleDateString()}`, margin, yPos);
    yPos += 6;
    const formula = lwFinalizedData.priorityFormula || 'if';
    const formulaText = formula === 'ifd' ? 'IF Ã— D' : 'I Ã— F';
    doc.text(`Priority Formula: ${formulaText}`, margin, yPos);
    yPos += 6;
    doc.text(`Total Participants: ${lwAggregatedResults.totalVotes}`, margin, yPos);
    yPos += 10;
    
    // Collect all tasks with metrics
    const allTasks = [];
    Object.keys(lwFinalizedData.duties).forEach(dutyId => {
        const duty = lwFinalizedData.duties[dutyId];
        duty.tasks.forEach(task => {
            if (task.priorityIndex !== undefined) {
                allTasks.push({
                    dutyTitle: duty.title,
                    taskText: task.text,
                    meanImportance: task.meanImportance,
                    meanFrequency: task.meanFrequency,
                    meanDifficulty: task.meanDifficulty,
                    priorityIndex: task.priorityIndex,
                    rank: task.rank
                });
            }
        });
    });
    
    allTasks.sort((a, b) => a.rank - b.rank);
    
    // Table header
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Rank', margin, yPos);
    doc.text('Duty', margin + 15, yPos);
    doc.text('Task', margin + 60, yPos);
    doc.text('I', margin + 140, yPos);
    doc.text('F', margin + 150, yPos);
    doc.text('D', margin + 160, yPos);
    doc.text('PI', margin + 170, yPos);
    yPos += 5;
    doc.line(margin, yPos, pageWidth - margin, yPos);
    yPos += 3;
    
    // Table rows
    doc.setFont('helvetica', 'normal');
    doc.setFontSize(8);
    
    allTasks.forEach(task => {
        checkPageBreak(8);
        
        doc.text(String(task.rank), margin, yPos);
        const dutyLines = doc.splitTextToSize(task.dutyTitle, 40);
        doc.text(dutyLines[0] || '', margin + 15, yPos);
        const taskLines = doc.splitTextToSize(task.taskText, 75);
        doc.text(taskLines[0] || '', margin + 60, yPos);
        doc.text(task.meanImportance.toFixed(2), margin + 140, yPos);
        doc.text(task.meanFrequency.toFixed(2), margin + 150, yPos);
        doc.text(task.meanDifficulty.toFixed(2), margin + 160, yPos);
        doc.text(task.priorityIndex.toFixed(2), margin + 170, yPos);
        yPos += 6;
    });
    
    doc.save(`${lwFinalizedData.occupation}_${lwFinalizedData.jobTitle}_Verified_Results.pdf`.replace(/[^a-z0-9_]/gi, '_'));
    showStatus('âœ… PDF exported successfully!', 'success');
}

// ===== LIVE WORKSHOP - VERIFIED RESULTS DOCX EXPORT =====
async function lwExportVerifiedDOCX() {
    if (!lwFinalizedData || !lwAggregatedResults) {
        showStatus('No verified results available. Please refresh voting results first.', 'error');
        return;
    }
    
    const { Document, Packer, Paragraph, Table, TableRow, TableCell, WidthType, TextRun, AlignmentType, BorderStyle } = docx;
    
    // Collect all tasks with metrics
    const allTasks = [];
    Object.keys(lwFinalizedData.duties).forEach(dutyId => {
        const duty = lwFinalizedData.duties[dutyId];
        duty.tasks.forEach(task => {
            if (task.priorityIndex !== undefined) {
                allTasks.push({
                    dutyTitle: duty.title,
                    taskText: task.text,
                    meanImportance: task.meanImportance,
                    meanFrequency: task.meanFrequency,
                    meanDifficulty: task.meanDifficulty,
                    priorityIndex: task.priorityIndex,
                    rank: task.rank
                });
            }
        });
    });
    
    allTasks.sort((a, b) => a.rank - b.rank);
    
    const formula = lwFinalizedData.priorityFormula || 'if';
    const formulaText = formula === 'ifd' ? 'I Ã— F Ã— D' : 'I Ã— F';
    
    // Create table rows
    const tableRows = [
        new TableRow({
            children: [
                new TableCell({ children: [new Paragraph({ text: 'Rank', bold: true })], width: { size: 8, type: WidthType.PERCENTAGE } }),
                new TableCell({ children: [new Paragraph({ text: 'Duty', bold: true })], width: { size: 22, type: WidthType.PERCENTAGE } }),
                new TableCell({ children: [new Paragraph({ text: 'Task', bold: true })], width: { size: 35, type: WidthType.PERCENTAGE } }),
                new TableCell({ children: [new Paragraph({ text: 'I', bold: true })], width: { size: 8, type: WidthType.PERCENTAGE } }),
                new TableCell({ children: [new Paragraph({ text: 'F', bold: true })], width: { size: 8, type: WidthType.PERCENTAGE } }),
                new TableCell({ children: [new Paragraph({ text: 'D', bold: true })], width: { size: 8, type: WidthType.PERCENTAGE } }),
                new TableCell({ children: [new Paragraph({ text: 'PI', bold: true })], width: { size: 11, type: WidthType.PERCENTAGE } })
            ]
        })
    ];
    
    allTasks.forEach(task => {
        tableRows.push(
            new TableRow({
                children: [
                    new TableCell({ children: [new Paragraph(String(task.rank))] }),
                    new TableCell({ children: [new Paragraph(task.dutyTitle)] }),
                    new TableCell({ children: [new Paragraph(task.taskText)] }),
                    new TableCell({ children: [new Paragraph(task.meanImportance.toFixed(2))] }),
                    new TableCell({ children: [new Paragraph(task.meanFrequency.toFixed(2))] }),
                    new TableCell({ children: [new Paragraph(task.meanDifficulty.toFixed(2))] }),
                    new TableCell({ children: [new Paragraph(task.priorityIndex.toFixed(2))] })
                ]
            })
        );
    });
    
    const doc = new Document({
        sections: [{
            children: [
                new Paragraph({
                    text: 'DACUM Live Pro',
                    heading: 'Heading1',
                    alignment: AlignmentType.CENTER
                }),
                new Paragraph({
                    text: 'Verified (Post-Vote) Results',
                    heading: 'Heading2',
                    alignment: AlignmentType.CENTER
                }),
                new Paragraph({ text: '' }),
                new Paragraph({ text: `Occupation: ${lwFinalizedData.occupation}` }),
                new Paragraph({ text: `Job Title: ${lwFinalizedData.jobTitle}` }),
                new Paragraph({ text: `Date: ${new Date().toLocaleDateString()}` }),
                new Paragraph({ text: `Priority Formula: ${formulaText}` }),
                new Paragraph({ text: `Total Participants: ${lwAggregatedResults.totalVotes}` }),
                new Paragraph({ text: '' }),
                new Table({ rows: tableRows, width: { size: 100, type: WidthType.PERCENTAGE } })
            ]
        }]
    });
    
    Packer.toBlob(doc).then(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${lwFinalizedData.occupation}_${lwFinalizedData.jobTitle}_Verified_Results.docx`.replace(/[^a-z0-9_]/gi, '_');
        a.click();
        URL.revokeObjectURL(url);
        showStatus('âœ… DOCX exported successfully!', 'success');
    });
}

function lwEscapeCSV(text) {
    return text.replace(/"/g, '""');
}

// ===== LIVE WORKSHOP - PARTICIPANT MODE DETECTION =====
// Check if URL has lwsession parameter (participant mode)
window.addEventListener('DOMContentLoaded', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const sessionParam = urlParams.get('lwsession');
    
    if (sessionParam) {
        // Participant mode - redirect to separate participant file
        // Get directory path without filename
        const currentPath = window.location.pathname;
        const directory = currentPath.substring(0, currentPath.lastIndexOf('/') + 1);
        const participantFileUrl = window.location.origin + directory + 'DACUM_LiveWorkshop_Participant.html';
        const redirectUrl = `${participantFileUrl}?lwsession=${sessionParam}`;
        
        // Redirect to participant page
        window.location.href = redirectUrl;
    } else {
        // Facilitator mode - check and show Live Workshop section
        setTimeout(lwCheckAndShowSection, 100);
    }
});

// ===== END LIVE WORKSHOP MODULE =====

// ===== COMPETENCY CLUSTERING MODULE =====

let clusteringData = {
    availableTasks: [],
    clusters: [],
    clusterCounter: 0
};

function getTaskCode(taskId) {
    // Extract duty number and task number from ID like "duty_2_3"
    const parts = taskId.split('_');
    if (parts.length >= 3) {
        const dutyNum = parseInt(parts[1]);
        const taskNum = parts[2];
        const dutyLetter = String.fromCharCode(64 + dutyNum); // 1->A, 2->B, etc.
        return `Task ${dutyLetter}${taskNum}`;
    }
    return '';
}

function bypassToClusteringTab() {
    initializeClusteringFromTasks();
    switchTab('clustering-tab');
}

function initializeClusteringFromTasks() {
    clusteringData.availableTasks = [];
    clusteringData.clusters = [];
    clusteringData.clusterCounter = 0;
    
    // Check if we have voting results
    if (lwAggregatedResults && lwAggregatedResults.taskResults) {
        // Use voted and ranked tasks
        const taskResults = lwAggregatedResults.taskResults;
        const allTasks = [];
        
        Object.keys(taskResults).forEach(taskId => {
            const voteData = taskResults[taskId];
            allTasks.push({
                id: taskId,
                text: voteData.taskText,
                dutyTitle: voteData.dutyTitle,
                priorityIndex: voteData.priorityIndex || 0
            });
        });
        
        // Sort by priority index (highest first)
        allTasks.sort((a, b) => b.priorityIndex - a.priorityIndex);
        clusteringData.availableTasks = allTasks;
    } else {
        // Use final task list without scores
        const duties = lwExtractDutiesAndTasks();
        const allTasks = [];
        
        Object.keys(duties).forEach(dutyId => {
            const duty = duties[dutyId];
            duty.tasks.forEach(task => {
                allTasks.push({
                    id: task.id,
                    text: task.text,
                    dutyTitle: duty.title,
                    priorityIndex: null
                });
            });
        });
        
        clusteringData.availableTasks = allTasks;
    }
    
    renderAvailableTasks();
    renderClusters();
}

function renderAvailableTasks() {
    const container = document.getElementById('availableTasksList');
    
    if (clusteringData.availableTasks.length === 0) {
        container.innerHTML = '<div class="no-tasks-message">All tasks have been assigned to clusters.</div>';
        document.getElementById('btnCreateCluster').disabled = true;
        return;
    }
    
    let html = '';
    clusteringData.availableTasks.forEach((task, index) => {
        const taskCode = getTaskCode(task.id);
        
        // Build cluster dropdown options
        let clusterOptions = '<option value="">Select Cluster</option>';
        clusteringData.clusters.forEach(cluster => {
            clusterOptions += `<option value="${cluster.id}">${cluster.name}</option>`;
        });
        
        html += `
            <div class="task-checkbox-item">
                <input type="checkbox" id="task_${index}" onchange="updateCreateClusterButton()">
                <label for="task_${index}" class="task-checkbox-label">
                    <strong>${taskCode}:</strong> ${task.text}
                </label>
                ${task.priorityIndex !== null ? `<span class="task-priority-badge">PI: ${task.priorityIndex.toFixed(2)}</span>` : ''}
                ${clusteringData.clusters.length > 0 ? `
                <div class="task-dropdown-container">
                    <span class="task-dropdown-label">Add to:</span>
                    <select class="task-reassign-dropdown" onchange="addTaskToClusterFromDropdown(${index}, this.value); this.value='';">
                        ${clusterOptions}
                    </select>
                </div>
                ` : ''}
            </div>
        `;
    });
    
    container.innerHTML = html;
    updateCreateClusterButton();
}

function updateCreateClusterButton() {
    const checkboxes = document.querySelectorAll('#availableTasksList input[type="checkbox"]');
    const anyChecked = Array.from(checkboxes).some(cb => cb.checked);
    document.getElementById('btnCreateCluster').disabled = !anyChecked;
}

function createCluster() {
    const checkboxes = document.querySelectorAll('#availableTasksList input[type="checkbox"]');
    const selectedIndices = [];
    
    checkboxes.forEach((cb, index) => {
        if (cb.checked) {
            selectedIndices.push(index);
        }
    });
    
    if (selectedIndices.length === 0) return;
    
    // Create new cluster
    clusteringData.clusterCounter++;
    const newCluster = {
        id: `cluster_${clusteringData.clusterCounter}`,
        name: `Cluster ${clusteringData.clusterCounter}`,
        tasks: []
    };
    
    // Move selected tasks to cluster (in reverse order to maintain indices)
    selectedIndices.sort((a, b) => b - a);
    selectedIndices.forEach(index => {
        newCluster.tasks.push(clusteringData.availableTasks[index]);
        clusteringData.availableTasks.splice(index, 1);
    });
    
    clusteringData.clusters.push(newCluster);
    
    renderAvailableTasks();
    renderClusters();
}

function renderClusters() {
    const container = document.getElementById('clustersContainer');
    
    if (clusteringData.clusters.length === 0) {
        container.innerHTML = '<div class="no-clusters-message">No clusters created yet.</div>';
        return;
    }
    
    let html = '';
    clusteringData.clusters.forEach(cluster => {
        html += `
            <div class="cluster-item">
                <div class="cluster-header">
                    <div class="cluster-title">${cluster.name}</div>
                    <div class="cluster-actions">
                        <button class="btn-rename-cluster" onclick="renameCluster('${cluster.id}')">
                            âœï¸ Rename
                        </button>
                        <button class="btn-delete-cluster" onclick="deleteCluster('${cluster.id}')">
                            ğŸ—‘ï¸ Delete
                        </button>
                    </div>
                </div>
                <div class="cluster-tasks-list">
                    ${cluster.tasks.map((task, index) => {
                        const taskCode = getTaskCode(task.id);
                        return `
                        <div class="cluster-task-item">
                            <div class="cluster-task-text">
                                <strong>${taskCode}:</strong> ${task.text}
                            </div>
                            <button class="btn-remove-task" onclick="removeTaskFromCluster('${cluster.id}', ${index})">
                                âœ•
                            </button>
                        </div>
                    `;
                    }).join('')}
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

function renameCluster(clusterId) {
    const cluster = clusteringData.clusters.find(c => c.id === clusterId);
    if (!cluster) return;
    
    const newName = prompt('Enter new cluster name:', cluster.name);
    if (newName && newName.trim()) {
        cluster.name = newName.trim();
        renderClusters();
    }
}

function deleteCluster(clusterId) {
    const clusterIndex = clusteringData.clusters.findIndex(c => c.id === clusterId);
    if (clusterIndex === -1) return;
    
    const cluster = clusteringData.clusters[clusterIndex];
    
    // Return all tasks to available
    clusteringData.availableTasks.push(...cluster.tasks);
    
    // Re-sort if we have priority indices
    if (clusteringData.availableTasks.length > 0 && clusteringData.availableTasks[0].priorityIndex !== null) {
        clusteringData.availableTasks.sort((a, b) => b.priorityIndex - a.priorityIndex);
    }
    
    // Remove cluster
    clusteringData.clusters.splice(clusterIndex, 1);
    
    renderAvailableTasks();
    renderClusters();
}

function removeTaskFromCluster(clusterId, taskIndex) {
    const cluster = clusteringData.clusters.find(c => c.id === clusterId);
    if (!cluster) return;
    
    const task = cluster.tasks[taskIndex];
    cluster.tasks.splice(taskIndex, 1);
    
    // Return task to available
    clusteringData.availableTasks.push(task);
    
    // Re-sort if we have priority indices
    if (clusteringData.availableTasks.length > 0 && clusteringData.availableTasks[0].priorityIndex !== null) {
        clusteringData.availableTasks.sort((a, b) => b.priorityIndex - a.priorityIndex);
    }
    
    renderAvailableTasks();
    renderClusters();
}

function addTaskToClusterFromDropdown(taskIndex, clusterId) {
    if (!clusterId) return;
    
    const cluster = clusteringData.clusters.find(c => c.id === clusterId);
    if (!cluster) return;
    
    const task = clusteringData.availableTasks[taskIndex];
    if (!task) return;
    
    // Add task to cluster
    cluster.tasks.push(task);
    
    // Remove from available tasks
    clusteringData.availableTasks.splice(taskIndex, 1);
    
    renderAvailableTasks();
    renderClusters();
}

// Auto-initialize clustering when switching to clustering tab
document.addEventListener('DOMContentLoaded', function() {
    const clusteringTab = document.querySelector('[data-tab="clustering-tab"]');
    if (clusteringTab) {
        clusteringTab.addEventListener('click', function() {
            if (clusteringData.availableTasks.length === 0 && clusteringData.clusters.length === 0) {
                initializeClusteringFromTasks();
            }
        });
    }
});

function switchTab(tabId) {
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabs.forEach(tab => tab.classList.remove('active'));
    tabContents.forEach(content => content.classList.remove('active'));
    
    const selectedTab = document.querySelector(`[data-tab="${tabId}"]`);
    const selectedContent = document.getElementById(tabId);
    
    if (selectedTab && selectedContent) {
        selectedTab.classList.add('active');
        selectedContent.classList.add('active');
    }
}

// ===== END COMPETENCY CLUSTERING MODULE =====

    </script>

    <!-- Loading Modal -->
    <div id="loadingModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; padding: 40px; border-radius: 16px; text-align: center;">
            <div class="spinner"></div>
            <p id="loadingText" style="margin-top: 20px; font-size: 1.1em; color: #333;">Processing...</p>
        </div>
    </div>

</body>
</html>
